# 一、三种继承方式

## 1. public

![img](https://cdn.nlark.com/yuque/0/2020/png/1237282/1586153094113-e0b4416b-aa7f-45c9-b1ce-54d10b1bcb7c.png)



## 2. private

![img](https://cdn.nlark.com/yuque/0/2020/png/1237282/1586153094105-b646a669-cafc-45d1-9200-8560513ed6ca.png)



#### 同名隐藏

如果派生类声明一个和某基类成员同名的新成员（如果是成员函数，则参数表也要相同，参数不同的情况属于重载），派生的新成员就隐藏了外层（基类）同名成员，称为同名隐藏



## 3. protected

<img src="https://cdn.nlark.com/yuque/0/2020/png/1237282/1586153094115-2c2166a4-4897-4504-936c-2eb49e04136a.png" alt="img" style="zoom:67%;" />



# 二、 类型兼容规则（类型转换）

**公有派生类对象可以被当作基类的对象使用**，反之则不可。

1. 派生类的对象可以隐含转换为基类对象；

    ```cpp
    class A;
    class B:public A
    A a1; B b1;
    a1 = b1;
    ```



2. 派生类的对象可以初始化基类的引用；

    ```cpp
    A &a = b1;
    ```



3. 派生类对象的地址可以隐含转换为基类的指 针。

    ```cpp
    A *ra ; 
    ra = &b1;
    ```



**在替代之后，派生类对象就可以作为基类的对象使用，但只能使用从基类继承的成员。**



例如：

![img](https://cdn.nlark.com/yuque/0/2020/png/1237282/1586153094122-c647ff10-875f-449b-ab58-57ba037ae9b9.png)



虽然根据类型兼容规则，可以将派生类对象的地址赋值给基类Base1的指针，

但是通过这个基类的指针（或者对象名）只能访问从基类继承的成员。

所以运行结果是：

> Base1 :: display( ) 	
>
> Base1 :: display( ) 	
>
> Base1 :: display( )



可以使用 **虚函数** 解决这个问题（详细解析见后续文章）

<img src="https://cdn.nlark.com/yuque/0/2020/png/1237282/1586153094084-cdc81384-db38-4e53-8dcf-e04f6fb122a5.png" alt="img" style="zoom:80%;" />



# 三、派生类的构造函数

<img src="https://cdn.nlark.com/yuque/0/2020/png/1237282/1586153094093-691b625f-0f06-4a3e-8354-6d7eb59c3c70.png" alt="img" style="zoom: 80%;" />

![img](https://cdn.nlark.com/yuque/0/2020/png/1237282/1586153094161-b768f1cf-0a9d-491d-9361-b52c176445c3.png)



按照 Base2，Base1，Base3的顺序调用基类的构造函数进行初始化，

按照 Base1，Base2，Base3的顺序初始化成员对象



**析构函数的调用顺序和构造函数的调用顺序正好相反**



# 四、访问从基类继承的成员

## 1. 二义性问题

<img src="https://cdn.nlark.com/yuque/0/2020/png/1237282/1586153094126-7038b0b3-1c43-4202-a481-a44496da4f5e.png" alt="img" style="zoom:80%;" />



如果**某个派生类的部分或全部基类都是从另一个共同的基类派生而来**，

在这些直接基类中，从上一级继承而来的成员就拥有相同的名称，因此派生类中就会出现同名现象。



**多继承时的二义性和冗余性问题：**

![img](https://cdn.nlark.com/yuque/0/2020/png/1237282/1586153094161-9dd1f64d-e1a6-401e-983b-73b302d1fbde.png)



使用作用域限定符，派生类的对象在内存中就同时拥有成员var0的多份同名副本，可赋不同的值，若**只需要一个这样的数据副本，使用虚基类**

## 2. 作用域限定

当派生类与基类中有相同成员时：

- 若未特别限定，则通过派生对象使用的是派生类中的同名成员（同名隐藏）
- 如果要通过派生类对象访问基类中被隐藏的同名成员，应使用基类名和作用域操作符 `：：` 来限定
   <img src="https://cdn.nlark.com/yuque/0/2020/png/1237282/1586153094167-95b963b5-baef-40e5-9cbe-c1ca806be5e5.png" alt="img" style="zoom: 80%;" />

使用作用域限定符，通过直接基类名来确定要访问的成员，这种情况下，

**派生类的对象在内存中就同时拥有成员var0的两份同名副本（Base1和Base2的）可赋不同的值**

可以使用类名限定解决多继承时的二义性问题



## 3. 虚基类

解决多继承（派生类继承多个小基类，这些小基类又都继承同一个大基类）时的二义性和冗余性问题

<img src="https://cdn.nlark.com/yuque/0/2020/png/1237282/1586153094127-bb237dac-c001-4bfe-a362-8415b20c9519.png" alt="img" style="zoom:80%;" />



举例：

<img src="https://cdn.nlark.com/yuque/0/2020/png/1237282/1586153094133-66b1dcc3-ceab-4765-aa5c-d16d57c8c772.png" alt="img" style="zoom:77%;" />



## 4. 虚基类和作用域分辨符比较

前者只维护一份成员副本，后者在派生类中拥有同名成员的多个副本，可以存放不同的数据。

相比之下，前者使用更为简洁，空间更为节省，后者可以容纳更多的数据