# 📥 类加载机制

---

## 1. 类的生命周期

一个类的完整生命周期包括以下 7 个阶段：

- **加载（Loading）**
- **验证（Verification）**
- **准备（Preparation）**
- **解析（Resolution）**
- **初始化（Initialization）**
- 使用（Using）
- 卸载（Unloading）：GC 将无用对象从内存中卸载

<img src="https://gitee.com/veal98/images/raw/master/img/20200907153005.png" style="zoom: 50%;" />

## 2. 类加载过程

如果 **JVM** 想要执行 **.class** 文件，需要将其装进一个 **类加载器** 中，它就像一个搬运工一样，会把所有的 **.class** 文件全部搬进 JVM 里面来：

![](https://gitee.com/veal98/images/raw/master/img/20200908103137.png)

❓ 那么 JVM 是如何加载这些 Class 文件呢？

系统加载 Class 类型的文件主要三步:**加载->连接->初始化**。连接过程又可分为三步:**验证->准备->解析**。

<img src="https://gitee.com/veal98/images/raw/master/img/20200907153144.png" style="zoom:50%;" />

### ① 加载

🚨 加载是类加载的一个阶段，注意不要混淆。

类加载过程的第一步，主要完成下面3件事情：

- 通过全类名获取定义此类的二进制字节流

- 将字节流所代表的静态存储结构转换为方法区的运行时数据结构

- 在内存中生成一个代表该类的 Class 对象, 作为方法区这些数据的访问入口

其中二进制字节流可以从以下方式中获取：

- 从 ZIP 包读取，成为 JAR、EAR、WAR 格式的基础。
- 从网络中获取，最典型的应用是 Applet。
- 运行时计算生成，例如动态代理技术，在 java.lang.reflect.Proxy 使用 ProxyGenerator.generateProxyClass 的代理类的二进制字节流。
- 由其他文件生成，例如由 JSP 文件生成对应的 Class 类。

### ② 验证

确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。

<img src="https://gitee.com/veal98/images/raw/master/img/20200907153356.png" style="zoom:50%;" />

### ③ 准备

**类变量**是被 `static `修饰的变量，**准备阶段为<u>类变量</u>分配内存并设置初始值**，使用的是方法区的内存。

实例变量不会在这阶段分配内存，它会在对象实例化时随着对象一起被分配在堆中。应该注意到，⭐ **实例化不是类加载的一个过程，类加载发生在所有实例化操作之前**，并且**类加载只进行一次，实例化可以进行多次**。

初始值一般为 0 值，例如下面的类变量 value 被初始化为 0 而不是 123。

```java
public static int value = 123;
```

如果类变量是常量 `final`，那么它将初始化为表达式所定义的值而不是 0。例如下面的常量 `value `被初始化为 123 而不是 0。

```java
public static final int value = 123;
```

### ④ 解析

将常量池的符号引用替换为直接引用的过程。

> 💡 **符号引用**就是一组符号来描述目标，可以是任何字面量。
>
> **直接引用**就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。
>
> 在程序实际运行时，只有符号引用是不够的，举个例子：在程序执行方法时，系统需要明确知道这个方法所在的位置。Java 虚拟机为每个类都准备了一张方法表来存放类中所有的方法。当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法了。通过解析操作符号引用就可以直接转变为目标方法在类中方法表的位置，从而使得方法可以被调用。

其中解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定。

### ⑤ 初始化

初始化阶段才真正开始执行类中定义的 Java 程序代码。**初始化阶段是虚拟机执行类构造器 `<clinit>()` 方法的过程**。<u>在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。</u>

`<clinit>()` 是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序决定。特别注意的是，🚨 **静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问**。例如以下代码：

```java
public class Test {
    static {
        i = 0;                // 给变量赋值可以正常编译通过
        System.out.print(i);  // 这句编译器会提示“非法向前引用”
    }
    static int i = 1;
}
```

由于父类的 `<clinit>()` 方法先执行，也就意味着**父类中定义的静态语句块的执行要优先于子类**。例如以下代码：

```java
static class Parent {
    public static int A = 1;
    static {
        A = 2;
    }
}

static class Sub extends Parent {
    public static int B = A;
}

public static void main(String[] args) {
     System.out.println(Sub.B);  // 2
}
```

接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成 `<clinit>()` 方法。但接口与类不同的是，**执行接口的 `<clinit>()` 方法不需要先执行父接口的 `<clinit>() `方法**。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的 `<clinit>() `方法。

虚拟机会保证一个类的` <clinit>() `方法在多线程环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行这个类的` <clinit>()` 方法，其它线程都会阻塞等待，直到活动线程执行 `<clinit>()` 方法完毕。如果在一个类的` <clinit>()` 方法中有耗时的操作，就可能造成多个线程阻塞，在实际过程中此种阻塞很隐蔽。

## 3. 类初始化时机

### ① 主动引用

虚拟机规范中并没有强制约束何时进行加载，但是规范**严格规定了有且只有下列五种情况必须对类进行初始化**（加载、验证、准备都会随之发生）：

- 遇到 `new`、`getstatic`、`putstatic`、`invokestatic` 这四条字节码指令时，如果类没有进行过初始化，则必须先触发其初始化。最常见的生成这 4 条指令的场景是：
  - 使用 `new `关键字实例化对象的时候；
  - 读取或设置一个类的静态字段（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）的时候；
  - 调用一个类的静态方法的时候。
- 使用 `java.lang.reflect` 包的方法对类进行反射调用的时候，如果类没有进行初始化，则需要先触发其初始化。
- 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
- 当虚拟机启动时，用户需要指定一个要执行的主类（包含 `main()` 方法的那个类），虚拟机会先初始化这个主类；
- 当使用 JDK 1.7 的动态语言支持时，如果一个 `java.lang.invoke.MethodHandle` 实例最后的解析结果为 `REF_getStatic`, `REF_putStatic`, `REF_invokeStatic` 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化；

### ② 被动引用

**以上 5 种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用**。被动引用的常见例子包括：

- 通过子类引用父类的静态字段，不会导致子类初始化。

    ```java
    System.out.println(SubClass.value);  // value 字段在 SuperClass 中定义
    ```

- 通过数组定义来引用类，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法。

    ```java
    SuperClass[] sca = new SuperClass[10];
    ```

- 常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。

    ```java
    System.out.println(ConstClass.HELLOWORLD);
    ```

## 4. 类加载器

### ① 类与类加载器

**两个类相等，需要类本身相等，并且使用同一个类加载器进行加载**。这是因为每一个类加载器都拥有一个独立的类名称空间。

<u>这里的相等，包括类的 Class 对象的 `equals()` 方法、`isAssignableFrom()` 方法、`isInstance() `方法的返回结果为 `true`，也包括使用 `instanceof` 关键字做对象所属关系判定结果为 `true`。</u>

### ② 类加载器分类

从 Java 虚拟机的角度来讲，只存在以下两种不同的类加载器：

- **启动类加载器（Bootstrap ClassLoader）**，使用 C++ 实现，是虚拟机自身的一部分；
- **所有其它类的加载器**，使用 Java 实现，独立于虚拟机，继承自抽象类 ` java.lang.ClassLoader`。

从 Java 开发人员的角度看，类加载器可以划分得更细致一些：

- **启动类加载器（Bootstrap ClassLoader）**此类加载器负责将存放在 `<JRE_HOME>\lib` 目录中的，或者被 `-Xbootclasspath` 参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 `rt.jar`，名字不符合的类库即使放在 `lib` 目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用 `null `代替即可。
- **扩展类加载器（Extension ClassLoader）**这个类加载器是由 `ExtClassLoader（sun.misc.Launcher$ExtClassLoader）`实现的。它负责将 `<JAVA_HOME>/lib/ext` 或者被 `java.ext.dir` 系统变量所指定路径中的所有类库加载到内存中，开发者可以直接使用扩展类加载器。
- **应用程序类加载器（Application ClassLoader）**这个类加载器是由 `AppClassLoader（sun.misc.Launcher$AppClassLoader）`实现的。由于这个类加载器是 `ClassLoader `中的 `getSystemClassLoader()` 方法的返回值，因此一般称为**系统类加载器**。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。

### ③ 双亲委派模型

应用程序是由三种类加载器互相配合从而实现类加载，除此之外还可以加入自己定义的类加载器。

下图展示了类加载器之间的层次关系，称为**双亲委派模型（Parents Delegation Model）**。该模型要求**除了顶层的启动类加载器外，其它的类加载器都要有自己的父类加载器**。<u>这里的父子关系一般通过组合关系（Composition）来实现，而不是继承关系（Inheritance）。</u>

<img src="https://gitee.com/veal98/images/raw/master/img/20200907155021.png" style="zoom: 60%;" />

#### Ⅰ 工作过程

**一个类加载器首先将类加载请求转发到父类加载器，只有当父类加载器无法完成时才尝试自己加载。**

#### Ⅱ 好处

使得 Java 类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一。

例如 `java.lang.Object` 存放在 `rt.jar` 中，如果编写另外一个 `java.lang.Object `并放到 ClassPath 中，程序可以编译通过。由于双亲委派模型的存在，所以在` rt.jar` 中的 `Object `比在 ClassPath 中的 `Object `优先级更高，这是因为 `rt.jar` 中的 `Object `使用的是启动类加载器，而 ClassPath 中的 `Object `使用的是应用程序类加载器。`rt.jar` 中的 `Object `优先级更高，那么<u>程序中所有的 `Object `都是这个 `Object`</u>。

#### Ⅲ 实现

以下是抽象类` java.lang.ClassLoader` 的代码片段，其中的` loadClass()` 方法运行过程如下：<u>先检查类是否已经加载过，如果没有则让父类加载器去加载。当父类加载器加载失败时抛出 `ClassNotFoundException`，此时尝试自己去加载。</u>

```java
public abstract class ClassLoader {
    // The parent class loader for delegation
    private final ClassLoader parent;

    public Class<?> loadClass(String name) throws ClassNotFoundException {
        return loadClass(name, false);
    }

    protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
        synchronized (getClassLoadingLock(name)) {
            // First, check if the class has already been loaded
            Class<?> c = findLoadedClass(name);
            if (c == null) {
                try {
                    if (parent != null) {
                        c = parent.loadClass(name, false);
                    } else {
                        c = findBootstrapClassOrNull(name);
                    }
                } catch (ClassNotFoundException e) {
                    // ClassNotFoundException thrown if class not found
                    // from the non-null parent class loader
                }

                if (c == null) {
                    // If still not found, then invoke findClass in order
                    // to find the class.
                    c = findClass(name);
                }
            }
            if (resolve) {
                resolveClass(c);
            }
            return c;
        }
    }

    protected Class<?> findClass(String name) throws ClassNotFoundException {
        throw new ClassNotFoundException(name);
    }
}
```

### ④ 自定义类加载器

除了 `BootstrapClassLoader` 其他类加载器均由 Java 实现且全部继承自 `java.lang.ClassLoader`。🚩 **如果我们要自定义自己的类加载器，很明显需要继承 `ClassLoader`。**

以下代码中的 `FileSystemClassLoader `是自定义类加载器，用于加载文件系统上的类。它<u>首先根据类的全名在文件系统上查找类的字节代码文件（`.class` 文件），然后读取该文件内容，最后通过 `defineClass()` 方法来把这些字节代码转换成 `java.lang.Class` 类的实例。</u>

`java.lang.ClassLoader` 的 `loadClass()` 实现了双亲委派模型的逻辑，自定义类加载器一般不去重写它，但是需要重写 ` findClass()` 方法。

```java
// 自定义类加载器
public class FileSystemClassLoader extends ClassLoader {

    private String rootDir;

    public FileSystemClassLoader(String rootDir) {
        this.rootDir = rootDir;
    }

    protected Class<?> findClass(String name) throws ClassNotFoundException {
        byte[] classData = getClassData(name);
        if (classData == null) {
            throw new ClassNotFoundException();
        } else {
            // 通过 `defineClass()` 方法来把这些字节代码转换成 `java.lang.Class` 类的实例
            return defineClass(name, classData, 0, classData.length);
        }
    }
	
    // 根据类的全名在文件系统上查找类的字节代码文件（.class 文件）
    private byte[] getClassData(String className) {
        String path = classNameToPath(className);
        try {
            InputStream ins = new FileInputStream(path);
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            int bufferSize = 4096;
            byte[] buffer = new byte[bufferSize];
            int bytesNumRead;
            while ((bytesNumRead = ins.read(buffer)) != -1) {
                baos.write(buffer, 0, bytesNumRead);
            }
            return baos.toByteArray();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return null;
    }

    private String classNameToPath(String className) {
        return rootDir + File.separatorChar
                + className.replace('.', File.separatorChar) + ".class";
    }
}
```

## 📚 References

- 《深入理解 Java 虚拟机 — 周志明 第 2 版》
- [JavaGuide — Github](https://snailclimb.gitee.io/javaguide/#/?id=jvm)
- [CS-Notes — Github](http://cyc2018.gitee.io/cs-notes/#/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA?id=%e7%b1%bb%e5%8a%a0%e8%bd%bd%e5%99%a8%e5%88%86%e7%b1%bb)