# ♻ 并发

---

## 1. 使用线程给其他任务提供机会

下面是在一个单独的线程中执行一个任务的简单过程：

1 ) 将任务代码移到实现了 `Runnable `接口的类的 `run `方法中。这个接口非常简单，只有 一个方法： 

```java
public interface Runnable { 
    void run();
}
```

由于 `Runnable `是一个函数式接口，可以用 lambda 表达式建立一个实例： 

```java
Runnable t = () -> {
	task code
};
```

2 ) 由 `Runnable `创建一个 `Thread `对象：

```java
Thread t = new Thread();
```

3 ) 启动线程：

```java
t.start();
```

💬 举个栗子：

```java
Runnable r = 0 -> {
    try{
        for (int i = 1; i <= STEPS; i ++){
            ball.move(comp.getBounds());
            comp.repaint();
            Thread.sleep(DELAY);
        }
    }
    catch (InterruptedException e){
    }
};
Thread t = new Thread(r);
t.start();
```

## 2. 中断线程 interrupt

当线程的 `run `方法执行方法体中最后一条语句后， 并经由执行 `return `语句返冋时，或者出现了在方法中没有捕获的异常时，线程将终止。 <u>在 Java 的早期版本中， 还有一个 `stop `方 法， 其他线程可以调用它终止线程。但是， 这个方法现在已经被弃用了</u>。后文将讨论它被弃用的缘由。

⭐ 没有可以强制线程终止的方法。然而，`interrupt `方法可以用来请求终止线程。 

**当对一个线程调用 `interrupt `方法时，线程的中断状态将被置位**。这是每一个线程都具有 的 `boolean `标志。每个线程都应该不时地检査这个标志， 以判断线程是否被中断。

要想弄清中断状态是否被置位，首先调用静态的 `Thread.currentThread` 方法获得当前线程， 然后调用 `isInterrupted` 方法： 

```java
while (!Thread.currentThread().isInterrupted()) { 
    // do more work 
} 
```

但是， 如果线程被阻塞， 就无法检测中断状态。这是产生 `InterruptedException `异常的地 方。当在一个被阻塞的线程（调用 `sleep `或 `wait`) 上调用 `interrupt `方法时，阻塞调用将会被 `Interrupted Exception` 异常中断。

被中断的线程可以决定如何响应中断。某些线程是如此重要以至于应该处理完异常后， 继续执行，而不理会中断。当然，更普遍的情况是，线程将简单地将中断作为一个终止 的请求。这种线程的 `run `方法具有如下形式：

```java
Runnable r = () -> {
    try{
        while (!Thread.currentThread().isInterrupted()){
            // do more work
        }
    }
    catch(InterruptedException e){
    	// thread was interr叩ted during sleep or wait
    }
    finally{
    	// clean up,if required
    }
    // exiting the run method terminates the thread
};
```

如果在每次工作迭代之后都调用 `sleep `方法（或者其他的可中断方法)， `isInterrupted `检测既没有必要也没有用处。⭐**如果在中断状态被置位时调用 `sleep `方法，它不会休眠。相反，它将清除这一状态，并拋出 `InterruptedException`**。因此， 如果你的循环调用 `sleep`，不会检 测中断状态。相反，要如下所示捕获 `InterruptedException `异常：

```java
Runnable r = () -> {
    try{
        while (!Thread.currentThread().isInterrupted()){
            // do more work
            Thread.sleep(delay);
        }
    }
    catch(InterruptedException e){
    	// thread was interr叩ted during sleep or wait
    }
    finally{
    	// clean up,if required
    }
    // exiting the run method terminates the thread
};
```

> 📜 有两个非常类似的方法，`interrupted `和 `isInterrupted`。`Interrupted `方法是一个静态方法， 它检测当前的线程是否被中断。 而且， 调用 `interrupted `方法会清除该线程的中断 状态。另一方面，`isInterrupted` 方法是一个实例方法，可用来检验是否有线程被中断。调用这个方法不会改变中断状态。

## 3. 线程状态

线程可以有如下 6 种状态： 

- New (新创建） 
- Runnable (可运行） 
- Blocked (被阻塞） 
- Waiting (等待） 
- Timed waiting (计时等待） 
- Terminated (被终止） 

要确定一个线程的当前状态， 可调用 `getState` 方法。

### ① 新创建线程 New

当用 `new` 操作符创建一个新线程时，如 `new Thread(r)`， 该线程还没有开始运行。这意味着它的状态是 `new`。

**当一个线程处于新创建状态时，程序还没有开始运行线程中的代码。在线程运行之前还有一些基础工作要做。**

### ② 可运行线程 Runnable

一旦调用 `start `方法，线程处于 `runnable `状态。**一个可运行的线程可能正在运行也可能没有运行， 这取决于操作系统给线程提供运行的时间。**（这就是为什么将这个状态称为可运行而不是运行)

一旦一个线程开始运行，它不必始终保持运行。事实上，运行中的线程被中断，目的是为了让其他线程获得运行机会。线程调度的细节依赖于操作系统提供的服务。

抢占式调度系统给每一个可运行线程一个时间片来执行任务。当时间片用完，操作系统剥夺该线程的运行权， 并给另一个线程运行机会。当选择下一个线程时， 操作系统考虑线程的优先级。 现在所有的桌面以及服务器操作系统都使用抢占式调度。

但是，像手机这样的小型设备可能使用协作式调度。在这样的设备中，一个线程只有在调用 `yield `方法、 或者被阻塞或等 待时，线程才失去控制权。 

<u>在具有多个处理器的机器上，每一个处理器运行一个线程， 可以有多个线程并行运行。 当然，如果线程的数目多于处理器的数目， 调度器依然采用时间片机制。</u>

### ③ 被阻塞线程 Blocked 和等待线程 Waiting

当线程处于被阻塞或等待状态时，它暂时不活动。它不运行任何代码且消耗最少的资源。直到线程调度器重新激活它。

- **当一个线程试图获取一个内部的对象锁（而不是 `java.util.concurrent` 库中的锁) ，而该锁被其他线程持有， 则该线程进人阻塞状态**（我们在 5.3 节讨论 `java.util.concurrent` 锁，在 5.5 节讨论内部对象锁) 。当所有其他线程释放该锁，并且线程调度器允许本线程持有它的时候，该线程将变成非阻塞状态。

- **当线程等待另一个线程通知调度器一个条件时，它自己进入等待状态。**（我们在第 5.4 节来讨论条件）在调用 `Object.wait` 方法或 `Thread.join` 方法， 或者是等待 `java.util.concurrent` 库中的 `Lock `或 `Condition `时， 就会出现这种情况。实际上，被阻塞状态与等待状态是有很大不同的。

- 有**几个方法有一个超时参数。调用它们导致线程进人计时等待（ timed waiting ) 状态。这一状态将一直保持到超时期满或者接收到适当的通知。**带有超时参数的方法有 `Thread.sleep` 和 `Object.wait`、`Thread.join`、 `Lock.tryLock` 以及` Condition.await` 的计时版。

🚩 图 14-3 展示了线程可以具有的状态以及从一个状态到另一个状态可能的转换。当一个线程被阻塞或等待时（或终止时) ，另一个线程被调度为运行状态。当一个线程被重新激活（例如， 因为超时期满或成功地获得了一个锁) ，调度器检查它是否具有比当前运行线程更高的优先级。如果是这样，调度器从当前运行线程中挑选一个， 剥夺其运行权，选择一个新的线程运行。

![](https://gitee.com/veal98/images/raw/master/img/20200626154230.png)

### ④ 被终止的线程 Terminated

线程因如下两个原因之一而被终止： 

- 因为 `run `方法正常退出而自然死亡。
- 因为一个没有捕获的异常终止了 `run `方法而意外死亡。

> 🚨 可以调用线程的 `stop `方法杀死一个线程。 该方法抛出 `ThreadDeath `错误对象, 由此杀死线程。但是，`stop `方法已过时， 不要在自己的代码中调用这个方法。

## 4. 线程属性

下面将讨论线程的各种属性，其中包括：线程优先级、守护线程、 线程组以及处理未捕获异常的处理器。

### ① 线程优先级 setPriority

在 Java 程序设计语言中，每一个线程有一个优先级。默认情况下， 一般线程继承它的父线程的优先级。可以用 `setPriority `方法提高或降低任何一个线程的优先级。可以将优先级设置为在 `MIN_PRIORITY` (在 Thread 类中定义为 1 ) 与` MAX_PRIORITY` (定义为 10 ) 之间的任何值。`NORM_PRIORITY `被定义为 5。

每当线程调度器有机会选择新线程时， 它首先选择具有较高优先级的线程。但是，线程优先级是高度依赖于系统的。当虚拟机依赖于宿主机平台的线程实现机制时， Java 线程的优先级被映射到宿主机平台的优先级上， 优先级个数也许更多，也许更少。 

例如，Windows 有 7 个优先级别。一些 Java 优先级将映射到相同的操作系统优先级。在 Oracle 为 Linux 提供的 Java 虚拟机中，线程的优先级被忽略一所有线程具有相同的优先级。 

> 🚨 如果确实要使用优先级， 应该避免初学者常犯的一个错误。如果有几个高优先级 的线程没有进入非活动状态， 低优先级的线程可能永远也不能执行。每当调度器决定运 行一个新线程时，首先会在具有高优先级的线程中进行选择， 尽管这样会使低优先级的线程完全饿死。

### ② 守护线程

**守护线程是程序运行时在后台提供服务的线程，<u>不属于</u>程序中不可或缺的部分。**

当所有前后线程结束时，程序也就终止，同时会杀死所有守护线程。

`main()` 属于非守护线程。

在线程启动之前使用 `setDaemon(true)` 方法可以将一个线程设置为守护线程。

<img src="https://gitee.com/veal98/images/raw/master/img/20200626201211.png" style="zoom:80%;" />

```java
public class daemon extends Thread{
    public void run(){
        for(int i = 0;i<10;i++)
            System.out.println(getName() + ":" + i);
    }

    public static void main(String[] args) {
        daemon ds = new daemon();
        ds.setDaemon(true);
        ds.start();
        System.out.println("main Thread End");
    }
}

```

> main Thread End
>
> Thread-0:0
>
> Thread-0:1
>
> Thread-0:2

当主线程结束时，守护线程也结束了，守护线程中的for循环一共可以循环10次，但只运行了3次就结束了。
`main`是前台进程，而ds因为设置了守护线程由前台进程变成了后台进程。

### ③ 未捕获异常处理器

线程的 `run`方法不能抛出任何受查异常， 但是，非受査异常会导致线程终止。在这种情况下，线程就死亡了。

但是，不需要任何 `catch`子句来处理可以被传播的异常。相反，就在线程死亡之前， 异常被传递到一个用于未捕获异常的处理器。该处理器必须属于一个实现` Thread.UncaughtExceptionHandler` 接口的类。这个接口只有 —个方法。

```java
void uncaughtException(Thread t, Throwable e)
```

可以用 `setUncaughtExceptionHandler `方法为任何线程安装一个处理器。也可以用 `Thread` 类的静态方法 `setDefaultUncaughtExceptionHandler `为所有线程安装一个默认的处理器。替换处理器可以使用日志 API 发送未捕获异常的报告到日志文件。

如果不安装默认的处理器， 默认的处理器为空。但是， 如果不为独立的线程安装处理器，此时的处理器就是该线程的 <u>`ThreadGroup ` 线程组</u>对象。

> 📜 线程组是一个可以统一管理的线程集合。默认情况下，创建的所有线程属于相同的线程组， 但是， 也可能会建立其他的组。现在引入了更好的特性用于线程集合的操作， 所以建议不要在自己的程序中使用线程组。

`ThreadGroup `类实现 `Thread.UncaughtExceptionHandler` 接口。它的 `uncaughtException `方 法做如下操作： 

- 1 ) 如果该线程组有父线程组， 那么父线程组的 `uncaughtException `方法被调用。 
- 2 ) 否则， 如果 `Thread.getDefaultExceptionHandler` 方法返回一个非空的处理器， 则调用该处理器。 
- 3 ) 否则，如果 `Throwable `是 `ThreadDeath `的一个实例， 什么都不做。 
- 4 ) 否则，线程的名字以及 `Throwable `的栈轨迹被输出到 `System.err `上。 

![](https://gitee.com/veal98/images/raw/master/img/20200626201836.png)

## 5. 同步

在大多数实际的多线程应用中， 两个或两个以上的线程需要共享对同一数据的存取。如果两个线程存取相同的对象， 并且每一个线程都调用了一个修改该对象状态的方法，将会发生什么呢？ 可以想象， 线程彼此踩了对方的脚。根据各线程访问数据的次序，可能会产生讹误的对象。这样一个情况通常称为**竞争条件（race condition)**。

### ① 竞争条件的一个例子

👉 <u>在本节中，你会看到如果没有使用同步会发生什么。</u>

在下面的测试程序中，模拟一个有若干账户的银行。随机地生成在这些账户之间转移钱款的交易。每一个账户有一个线程。每一笔交易中，会从线程所服务的账户中随机转移一定数目的钱款到另一个随机账户。 

我们有具有 `transfer `方法的 `Bank `类。该方法从一个账户转移一定数目的钱款到另一个账户（还没有考虑负的账户余额)。具体代码如下：

```java
import java.util.Arrays;

public class Bank {
    private final double[] accounts; // 账户

    /** 
     * 构造函数
     * @param n 账户个数
     * @param initialBalance 初始金额
     */
    public Bank(int n, double initialBalance){
        accounts = new double[n];
        Arrays.fill(accounts,initialBalance);
    }

    /**
     * 从一个账户转移一定金额到另一个账户
     * @param from 转出账户下标
     * @param to 转入账户下标
     * @param amount 转出金额
     */
    public void transfer(int from, int to, double amount){
        // 余额不足
        if(accounts[from] < amount)
            return;
        System.out.print(Thread.currentThread());
        accounts[from] -= amount;
        System.out.printf("%10.2f from %d to %d", amount, from, to);
        accounts[to] += amount;
        System.out.printf("Total Balance: %10.2f%n",getTotalBalance());
    }

    /**
     * 查询所有账户的余额
     * @return
     */
    public double getTotalBalance(){
        double sum = 0;
        for(double a : accounts){
            sum += a;
        }
        return sum;
    }

    /**
     * 查询所有账户个数
     * @return
     */
    public int size(){
        return accounts.length;
    }
}
```

`Runnable `类的 `run `方法不断地从一个固定的银行账户取出钱款。在每 一次迭代中，`run `方法随机选择一个目标账户和一个随机账户，调用 `bank `对象的 `transfer `方法，然后睡眠。具体代码如下：

```java
public class UnsynchBankTest {
    public static final int NACCOUNTS = 100; // 账户数量
    public static final double INITIAL_BALANCE = 100; // 账户初始余额
    public static final double MAX_AMOUNT = 1000; // 最大转账金额
    public static final int DELAY = 10; 

    public static void main(String[] args){
        Bank bank = new Bank(NACCOUNTS, INITIAL_BALANCE);
        for(int i = 0; i < NACCOUNTS; i ++){
            int fromAccount = i; // 转出账户下标
            // 创建线程
            Runnable r = () -> {
                try {
                    while(true){
                        int toAccount = (int)(bank.size() * Math.random()); // 随机选取转入账户下标
                        double amount = MAX_AMOUNT * Math.random(); // 随机定义转出金额
                        bank.transfer(fromAccount, toAccount, amount);
                        Thread.sleep((int)(DELAY*Math.random())); // 随机等待时间
                    }
                } catch (InterruptedException e) {
                    //TODO: handle exception
                }
            };
            Thread t = new Thread(r);
            t.start();
        } // end for
    }
}
```

当这个模拟程序运行时，不清楚在某一时刻某一银行账户中有多少钱。但是，**知道所有账户的总金额应该保持不变**， 因为所做的一切不过是从一个账户转移钱款到另一个账户。

> 📜 本程序永远不会结束。 只能按` CTRL+C` 来终止这个程序。

下面是典型的输出：

![](https://gitee.com/veal98/images/raw/master/img/20200626211025.png)

可以发现，总余额在一段时间后出现混乱。

### ② 竞争条件详解

上一节中运行了一个程序，其中有几个线程更新银行账户余额。一段时间之后， 错误不知不觉地出现了，总额要么增加， 要么变少。当两个线程试图同时更新同一个账户的时候， 这个问题就出现了。假定两个线程同时执行指令 :

```java
accounts[to] += amount;
```

问题在于**这不是原子操作**。该指令的处理过程如下： 

- 1 ) 将 `accounts[to]` 加载到寄存器。 
- 2 ) 增加 `amount`。 
- 3 ) 将结果写回 `accounts[to]`。

现在，假定第 1 个线程执行步骤 1 和 2, 然后， 它被剥夺了运行权。第 2 个线程被 唤醒并修改了 `accounts ` 数组中的同一项。然后，第 1 个线程被唤醒并完成其第 3 步。 这样， 第二个线程所做的更新丢失了。于是， 总金额不再正确。

![](https://gitee.com/veal98/images/raw/master/img/20200626212135.png)

### ③ 锁对象 Lock — ReentrantLock (显式锁)

有两种机制防止代码块受并发访问的干扰。

- `synchronized` 关键字 —— 内部锁（见 第 ⑤ 节）

- Java SE 5.0 引入了 `ReentrantLock `类，位于`java.util.concurrent.locks`包下 —— 显式锁 (本节讲解)

  用 `ReentrantLock `保护代码块的基本结构如下：

  ![](https://gitee.com/veal98/images/raw/master/img/20200626212944.png)

  这一结构确保任何时刻只有一个线程进人临界区。一旦一个线程封锁了锁对象， 其他任何线程都无法通过 `lock `语句。当其他线程调用 `lock `时，它们被阻塞，直到第一个线程释放锁对象。

  > 🚨 把解锁操作括在 `finally `子句之内是至关重要的。如果在临界区的代码抛出异常， 锁必须被释放。否则， 其他线程将永远阻塞。 

  > 📜 如果使用锁， 就不能使用带资源的 `try `语句。首先， 解锁方法名不是 `close`。不过， 即使将它重命名， 带资源的 try 语句也无法正常工作。它的首部希望声明一个新变量。但 是如果使用一个锁， 你可能想使用多个线程共享的那个变量（而不是新变量）。

😊 让我们使用一个锁来保护 `Bank` 类的 `transfer `方法：

```java
import java.util.Arrays;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class Bank {
    private final double[] accounts; // 账户

    public Lock bankLock = new ReentrantLock(); // ReentrantLock implements the Lock interface
    
	......
        
    public void transfer(int from, int to, double amount){
        bankLock.lock();
        try {
            // 余额不足
            if (accounts[from] < amount)
                return;
            System.out.print(Thread.currentThread());
            accounts[from] -= amount;
            System.out.printf("%10.2f from %d to %d", amount, from, to);
            accounts[to] += amount;
            System.out.printf("Total Balance: %10.2f%n", getTotalBalance());
        } catch (Exception e) {
            //TODO: handle exception
        } finally{
            bankLock.unlock();
        }
    }
    
	······
```

结果如下：

![](https://gitee.com/veal98/images/raw/master/img/20200626214448.png)

假定一个线程调用 `transfer`, 在执行结束前被剥夺了运行权。假定**第二个线程也调用 `transfer`, 由于第二个线程不能获得锁， 将在调用 `lock `方法时被阻塞。它必须等待第一个线程完成 `transfer `方法的执行之后才能再度被激活**。当第一个线程释放锁时， 那么第二个线程才能开始运行。

![](https://gitee.com/veal98/images/raw/master/img/20200626214818.png)

> 📜 注意**每一个 Bank 对象有自己的 `ReentrantLock `对象**。如果两个线程试图访问同一个 `Bank `对象，那么锁以串行方式提供服务。但是， **如果两个线程访问不同的 `Bank `对象， 每一个线程得到不同的锁对象， 两个线程都不会发生阻塞**。本该如此，因为线程在操纵不同的 Bank 实例的时候， 线程之间不会相互影响。

**锁是可重入的**， 因为线程可以重复地获得已经持有的锁。锁保持一个持有计数（ hold count ) 来跟踪对 `lock `方法的嵌套调用。线程在每一次调用 `lock `都要调用 `unlock `来释放锁。 由于这一特性， **被一个锁保护的代码可以调用另一个使用相同的锁的方法**。

例如，`transfer `方法调用 `getTotalBalance `方法， 这也会封锁 `bankLock `对象，此时 `bankLock `对象的持有计数为 2。当 `getTotalBalance `方法退出的时候， 持有计数变回 1。当 `transfer `方法退出的时候， 持有计数变为 0。线程释放锁。

通常， 可能想要保护需若干个操作来更新或检查共享对象的代码块。要确保这些操作完成后， 另一个线程才能使用相同对象。

👉 本节中部分 API 如下：

![](https://gitee.com/veal98/images/raw/master/img/20200626215513.png)

> 🚨 听起来公平锁更合理一些，但是**使用公平锁比使用常规锁要慢很多**。 只有当你确实了解自己要做什么并且对于你要解决的问题有一个特定的理由必须使用公平锁的时候， 才可以使用公平锁。 即使使用公平锁， 也无法确保线程调度器是公平的。 如果线程调度器选择忽略一个线程， 而该线程为了这个锁已经等待了很长时间， 那么就没有机会公平地处理这个锁了。

### ④ 条件对象 Condition

通常， 线程进人临界区，却发现在某一条件满足之后它才能执行。**要使用一个条件对象来管理那些已经获得了一个锁但是却不能做有用工作的线程**。在这一节里， 我们介绍 Java 库中条件对象的实现。（由于历史的原因， 条件对象经常被称为条件变量（ conditional variable ) ）。 

现在来细化银行的模拟程序。我们避免选择没有足够资金的账户作为转出账户。

⚠ 注意不能使用下面这样的代码：

```java
if(bank.getBalance(from) >= amount)
    // thread might be deactivated at this point
    bank.transfer(from, to, amount);
```

当前线程完全有可能在成功地完成测试，且在调用 `transfer `方法之前将被中断。

在线程再次运行前，账户余额可能已经低于提款金额。**必须确保没有其他线程在本次检査余额与转账活动之间修改余额。**通过使用锁来保护检査与转账动作来做到这一点：

```java
 public void transfer(int from, int to, double amount){
        bankLock.lock();
        try {
            // 余额不足
            while (accounts[from] < amount){
				// wait
                ......
            }
            
            ......
                
        } catch (Exception e) {
            //TODO: handle exception
        } finally{
            bankLock.unlock();
        }
    }
```

❓ 当账户中没有足够的余额时， 应该做什么呢？

 等待直到另一个线程向账户中注入 了资金。但是，这一线程刚刚获得了对 `bankLock `的排它性访问， 因此别的线程没有进行存款操作的机会。<u>这就是为什么我们需要条件对象的原因。</u>

**一个锁对象可以有一个或多个相关的条件对象。你可以用 `newCondition `方法获得一个条 件对象**。习惯上给每一个条件对象命名为可以反映它所表达的条件的名字。例如，在此设置 一个条件对象来表达“ 余额充足” 条件：

```java
class Bank{
    ...
    private Condition sufficientFunds;
    ...
    public Bank(){
        ...
    	sufficientFunds = bankLock.newCondition();
    }
}
```

如果 `transfer` 方法发现余额不足，它调用

```java
sufficientFunds.await();
```

当前线程现在被阻塞了，并放弃了锁。我们希望这样可以使得另一个线程可以进行增加账户余额的操作。 

⭐ **等待获得锁的线程和调用 `await `方法的线程存在本质上的不同。*<u>*一旦一个线程调用 `await `方法， 它进入该条件的等待集。当锁可用时，该线程不能马上解除阻塞。相反，它处于阻塞状态，直到另一个线程调用同一条件上的 `signalAll `方法时为止。</u>

当另一个线程转账时， 它应该调用

```java
sufficientFunds.signalAll();
```

这一调用重新激活因为这一条件而等待的所有线程。当这些线程从等待集当中移出时， 它们再次成为可运行的，调度器将再次激活它们。同时， 它们将试图重新进入该对象。一旦锁成为可用的，它们中的某个将从 `await `调用返回， 获得该锁并从被阻塞的地方继续执行。 

此时， 线程应该再次测试该条件。 由于无法确保该条件被满足（`signalAll ` 方法仅仅是通知正在等待的线程），此时有可能已经满足条件， 值得再次去检测该条件。

> 📜 通常， 对 `await `的调用应该在如下形式的循环体中 
>
> ```java
> while (...) 
>     condition.await();
> ```

至关重要的是最终需要某个其他线程调用 `signalAll `方法。当一个线程调用 `await `时，它 没有办法重新激活自身。它寄希望于其他线程。如果没有其他线程来重新激活等待的线程， 它就永远不再运行了。这将导致**死锁（ deadlock )** 现象。如果所有其他线程被阻 塞， 最后一个活动线程在解除其他线程的阻塞状态之前就调用 `await `方法， 那么它也被阻塞。 没有任何线程可以解除其他线程的阻塞，那么该程序就挂起了。 

应该何时调用 `signalAll` 呢？ 经验上讲， 在对象的状态有利于等待线程的方向改变时调用 `signalAll`。例如， 当一个账户余额发生改变时，等待的线程会应该有机会检查余额。在例子中， 当完成了转账时， 调用 `signalAll `方法：

```java
public void transfer(int from, int to, double amount){
    bankLock.lock();
    try {
        // 余额不足
        while (accounts[from] < amount){
            // wait
            sufficientFunds.await();
        }
        // 转账操作 start
        System.out.print(Thread.currentThread());
        accounts[from] -= amount;
        System.out.printf("%10.2f from %d to %d", amount, from, to);
        accounts[to] += amount;
        System.out.printf("Total Balance: %10.2f%n", getTotalBalance());
        // 转账操作 end

        sufficientFunds.signalAll();

    }  finally{
        bankLock.unlock();
    }
}
```

注意调用 `signalAll `不会立即激活一个等待线程。它仅仅解除等待线程的阻塞， 以便这些线程可以在当前线程退出同步方法之后，通过竞争实现对对象的访问。

> 📜 另一个方法 `signal`, 则是随机解除等待集中某个线程的阻塞状态。**这比解除所有线程的阻塞更加有效，但也存在危险**。如果随机选择的线程发现自己仍然不能运行， 那么它再次被阻塞。如果没有其他线程再次调用 `signal`, 那么系统就死锁了。

<br>

😉 OK，我们修改后的 `Bank `类的所有代码如下：

```java
package code_14_5;

import java.util.Arrays;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class Bank {
    private final double[] accounts; // 账户
    public Lock bankLock;
    private Condition sufficientFunds;

    /** 
     * 构造函数
     * @param n 账户个数
     * @param initialBalance 初始金额
     */
    public Bank(int n, double initialBalance){
        accounts = new double[n];
        Arrays.fill(accounts,initialBalance);
        bankLock = new ReentrantLock();
        sufficientFunds = bankLock.newCondition();
    }

    /**
     * 从一个账户转移一定金额到另一个账户
     * @param from 转出账户下标
     * @param to 转入账户下标
     * @param amount 转出金额
     */
    public void transfer(int from, int to, double amount){
        bankLock.lock();
        try {
            // 余额不足
            while (accounts[from] < amount){
                // wait
                sufficientFunds.await();
            }
            System.out.print(Thread.currentThread());
            accounts[from] -= amount;
            System.out.printf("%10.2f from %d to %d", amount, from, to);
            accounts[to] += amount;
            System.out.printf("Total Balance: %10.2f%n", getTotalBalance());
            sufficientFunds.signalAll();
        } catch (Exception e) {
            //TODO: handle exception
        } finally{
            bankLock.unlock();
        }
    }

    /**
     * 查询所有账户的余额
     * @return
     */
    public double getTotalBalance() {
        bankLock.lock();
        try {
            double sum = 0;
            for (double a : accounts) {
                sum += a;
            }
            return sum;
        } finally {
            bankLock.unlock();
        }

    }

    /**
     * 查询所有账户个数
     * @return
     */
    public int size(){
        return accounts.length;
    }
}
```

![](https://gitee.com/veal98/images/raw/master/img/20200627105816.png)

👇 相关 API 如下：

![](https://gitee.com/veal98/images/raw/master/img/20200627110304.png)

### ⑤ synchronized 关键字 — 内部锁（同步方法）

在前面一节中， 介绍了如何使用 `Lock `和 `Condition `对象。在进一步深入之前，⭐ 总结一下有关锁和条件的关键之处： 

- **锁用来保护代码片段，任何时刻只能有一个线程执行被保护的代码。** 
- 锁可以管理试图进入被保护代码段的线程。 
- 锁可以拥有一个或多个相关的条件对象。 
- **每个条件对象管理那些已经进入被保护的代码段但还不能运行的线程。**

<u>`Lock `和 `Condition `接口为程序设计人员提供了高度的锁定控制。然而，大多数情况下， 并不需要那样的控制，并且可以使用一种嵌人到 Java 语言内部的机制。从 1.0 版开始，Java 中的每一个对象都有一个内部锁。如果一个方法用 `synchronized`关键字声明，那么对象的锁将保护整个方法。</u>也就是说，要调用该方法，线程必须获得内部的对象锁。

换句话说：

![](https://gitee.com/veal98/images/raw/master/img/20200627111337.png)

💬 例如， 可以简单地声明 `Bank `类的 `transfer `方法为 `synchronized`, 而不是使用一个显式的锁。

内部对象锁只有一个相关条件。`wait `方法添加一个线程到等待集中，`notifyAll`/`notify`方法解除等待线程的阻塞状态。调用 `wait` 或 `notifyAll `等价于

![](https://gitee.com/veal98/images/raw/master/img/20200627111600.png)

> 📜 `wait`、`notifyAll `以及 `notify `方法是 `Object` 类的 `final `方法。`Condition `方法必须被命 名为 `await`、`signalAll `和 `signal `以便它们不会与那些方法发生冲突。

![](https://gitee.com/veal98/images/raw/master/img/20200627113835.png)

例如：利用 `synchronized `实现 `Bank `类如下：

```java
public class Bank {
    private final double[] accounts; // 账户
	
    ......

    /**
     * 从一个账户转移一定金额到另一个账户
     * @param from 转出账户下标
     * @param to 转入账户下标
     * @param amount 转出金额
     */
    public synchronized void transfer(int from, int to, double amount) throws InterruptedException{
        
        // 余额不足
        while (accounts[from] < amount){
            // wait
            wait();
        }
        System.out.print(Thread.currentThread());
        accounts[from] -= amount;
        System.out.printf("%10.2f from %d to %d", amount, from, to);
        accounts[to] += amount;
        System.out.printf("Total Balance: %10.2f%n", getTotalBalance());

        notifyAll();
     
    }

    /**
     * 查询所有账户的余额
     * @return
     */
    public synchronized double getTotalBalance() {   
      double sum = 0;
      for (double a : accounts) {
          sum += a;
      }
      return sum; 
    }
    
    ......

}
```

可以看到， 使用 `synchronized `关键字来编写代码要简洁得多。

将静态方法声明为 `synchronized` 也是合法的。如果调用这种方法，该方法获得相关的类对象的内部锁。例如，如果 `Bank `类有一个静态同步的方法，那么当该方法被调用时，`Bank.class` 对象的锁被锁住。因此，没有其他线程可以调用同一个类的这个或任何其他的同步静态方法。

内部锁和条件存在一些局限。包括： 

- 不能中断一个正在试图获得锁的线程。 
- 试图获得锁时不能设定超时。 
- 每个锁仅有单一的条件， 可能是不够的。

### ⑥ 同步阻塞 （同步代码块）

每一个 Java 对象有一个锁。线程可以通过调用同步方法获得锁。还有另一种机制可以获得锁，通过进入一个同步阻塞（`synchronized `关键字可以用于方法中的某个区块中，**表示只对这个区块的资源实行互斥访问**）。当线程进入如下形式的阻塞：

```java
synchonized(obj){
    // ...
}
```

于是它获得 `obj `的锁。

有时会发现“ 特殊的” 锁，例如：

```java
public class Bank{
    private doublet] accounts;
    private Object lock = new Object;
    ...
        
    public void transfer(int from, int to, int amount){
        synchronized (lock){
            accounts[from] -= amount;
            accounts[to] += amount;
        }
        System.out.println(...)
    }
}
```

在此，`lock` 对象被创建仅仅是用来使用每个 Java 对象持有的锁。

### ⑦ Volatile 域

有时，仅仅为了读写一个或两个实例域就使用同步， 显得开销过大了。

`volatile `关键字为实例域的同步访问提供了一种免锁机制。如果声明一个域为 `volatile `, 那么编译器和虚拟机就知道该域是可能被另一个线程并发更新的。

例如， 假定一个对象有一个布尔标记 `done `, 它的值被一个线程设置却被另一个线程査询，我们可以使用锁：

```java
private boolean done;
public synchronized boolean isDone() { 
    return done; 
}
public synchronized void setDone() { 
    done = true; 
}
```

或许使用内部锁不是个好主意。如果另一个线程已经对该对象加锁，`isDone `和 `setDone `方法可能阻塞。如果注意到这个方面， 一个线程可以为这一变量使用独立的 `Lock`。但是，这 也会带来许多麻烦。

在这种情况下，将域声明为 `volatile `是合理的：

```java
private volatile boolean done;
public boolean isDone() { 
    return done; 
}
public void setDone() { 
    done = true; 
}
```

> 🚨 **`Volatile `变量不能提供原子性**。例如， 方法：
>
> ```java
>  public void flipDone() { 
>      done = !done;  // not atomic 
>  } 
> ```
>
> **不能确保翻转域中的值，不能保证读取、 翻转和写入不被中断**。

### ⑧ final 变量

上一节已经了解到， 除非使用锁或 `volatile `修饰符，否则无法从多个线程安全地读取一个域。 

还有一种情况可以安全地访问一个共享域， 即这个域声明为 `final `时。考虑以下声明： 

```java
final Map<String, Double> accounts = new HashMap<>();
```

其他线程会在构造函数完成构造之后才看到这个 `accounts `变量。 

如果不使用 `final`，就不能保证其他线程看到的是 `accounts `更新后的值，它们可能都只是看到 `null `, 而不是新构造的 `HashMap`。 

当然，对这个映射表的操作并不是线程安全的。如果多个线程在读写这个映射表，仍然需要进行同步。

### ⑨ 原子性

#### Ⅰ AtomicLong 类

假设<u>对共享变量除了赋值之外并不完成其他操作，那么可以将这些共享变量声明为 `volatile`</u>

`java.util.concurrent.atomic` 包中有很多类使用了很高效的机器级指令（而不是使用锁） 来保证其他操作的原子性。 例如， <u>`AtomicLong `类提供了方法 `incrementAndGet `和 `decrementAndGet`, 它们分别以原子方式将一个整数自增或自减</u>。例如，可以安全地生成一个数值序列，如下所示：

```java
public static AtomicLong nextNumber = new AtomicLong();
long id = nextNumber.incrementAndGet();
```

`incrementAndGet `方法以原子方式将 `AtomicLong `自增， 并返回自增后的值。<u>也就是说， 获得值、 增 1 并设置然后生成新值的操作不会中断。</u>可以保证即使是多个线程并发地访问同一个实例，也会计算并返回正确的值。

👉：`AtomicLong ` 部分源码如下：

```java
public class AtomicLong extends Number implements java.io.Serializable {
    
	......

    public AtomicLong(long initialValue) {
        value = initialValue;
    }

    /**
     * Creates a new AtomicLong with initial value {@code 0}.
     */
    public AtomicLong() {
    }

    /**
     * Gets the current value.
     *
     * @return the current value
     */
    public final long get() {
        return value;
    }

    /**
     * Sets to the given value.
     *
     * @param newValue the new value
     */
    public final void set(long newValue) {
        value = newValue;
    }
	
    /**
     * Atomically increments by one the current value.
     *
     * @return the updated value
     */
    public final long incrementAndGet() {
        return unsafe.getAndAddLong(this, valueOffset, 1L) + 1L;
    }

    /**
     * Atomically decrements by one the current value.
     *
     * @return the updated value
     */
    public final long decrementAndGet() {
        return unsafe.getAndAddLong(this, valueOffset, -1L) - 1L;
    }

    /**
     * Atomically sets the value to the given updated value
     * if the current value {@code ==} the expected value.
     *
     * @param expect the expected value
     * @param update the new value
     * @return {@code true} if successful. False return indicates that
     * the actual value was not equal to the expected value.
     */
    public final boolean compareAndSet(long expect, long update) {
        return unsafe.compareAndSwapLong(this, valueOffset, expect, update);
    }
    
    ......
}

```

> 📜 类 `AtomicInteger`、`AtomicIntegerArray`、`AtomicIntegerFieldUpdater`、`AtomicLongArray`、 `AtomicLongFieldUpdater`、`AtomicReference`、`AtomicReferenceArray `和 `AtomicReferenceFieldUpdater `也同样提供了这些方法。

⭐ 有很多方法可以以原子方式设置和增减值， 不过， <u>如果希望完成更复杂的更新，就必须使用 `compareAndSet` 方法（**CAS**）。</u>

从注释来看，就是判断当前对象和期望的 expect 是否一致，如果一致则返回 true，且还做了一步自增操作；

🚩 **可以理解为如下操作：**

```java
if (this == expect) {
    this = update
    return true;
} else {
    return false;
}
```

💬 例如， 假设希望跟踪不同线程观察的最大值。下面的代码是不可行的：

```java
public static AtomicLong largest = new AtomicLong();
// 在某些线程中
largest.set(Math.max(!largest.get(),observed)); // 错误--竞争条件
```

这个更新不是原子的。实际上，应当在一个循环中计算新值和使用 `compareAndSet`:

```java
do {
    oldValue = largest.get();
    newValue = Math.max(oldValue, observed);
} while (!largest.compareAndSet(oldValue, newValue));
```

<u>如果另一个线程也在更新 `largest`，就可能阻止这个线程更新。这样一来，`compareAndSet `会返回 `false`, 而不会设置新值。</u>在这种情况下，循环会更次尝试，读取更新后的值，并尝试修改。最终， 它会成功地用新值替换原来的值。<u>这听上去有些麻烦， 不过 `compareAndSet `方法会映射到一个处理器操作， 比使用锁速度更快。</u>

在 Java SE 8 中，不再需要编写这样的循环样板代码。实际上，可以提供一个 lambda 表 达式更新变量，它会为你完成更新。对于这个例子，我们可以调用： 

```java
largest.updateAndGet(x -> Math.max(x, observed));
```

#### Ⅱ LongAdder / LongAccumulator 类

如果有大量线程要访问相同的原子值，性能会大幅下降，因为乐观更新需要太多次重试。Java SE 8 提供了 `LongAdder `和 `LongAccumulator `类来解决这个问题。`LongAdder `包括多个变量（加数)， 其总和为当前值。可以有多个线程更新不同的加数，线程个数增加时会自动 提供新的加数。通常情况下， 只有当所有工作都完成之后才需要总和的值， 对于这种情况， 这种方法会很高效。性能会有显著的提升。 

**如果认为可能存在大量竞争， 只需要使用 `LongAdder `而不是 `AtomicLong`**。<u>调用 `increment `让计数器自增，或者调用 `add `来增加一个量， 或者调用 `sum `来获取总和。</u>

```java
final LongAdder adder = new LongAdder();
for (. . .)
	pool .submit(() -> {
        while (. . .) {
            if (. . .) 
                adder.increment();
        }
	});
......
long total = adder.sum();
```

> 📜 当然，`increment `方法不会返回原值。这样做会消除将求和分解到多个加数所带来的性能提升。

<u>`LongAccumulator `将这种思想推广到任意的累加操作。在构造器中，可以提供这个操作以及它的零元素。</u>要加入新的值， 可以调用 `accumulate`。调用 `get `来获得当前值。下面的代码可以得到与 `LongAdder `同样的效果： 

```java
LongAccumulator adder = new LongAccumulator(Long::sum, 0); 
// In some thread...
adder.accumulate(value);
```

> 📜 `DoubleAdder `和 `DoubleAccumulator `也采用同样的方式， 只不过处理的是 double 值。

### ⑩ 死锁

锁和条件不能解决多线程中的所有问题。考虑下面的情况

![](https://gitee.com/veal98/images/raw/master/img/20200627145704.png)

线程 1 和线程 2 都被阻塞了。因为账户 1 以及账户 2 中的余额都不足以 进行转账，两个线程都无法执行下去。

有可能会因为每一个线程要等待更多的钱款存入而导致所有线程都被阻塞。这样的状态称为**死锁（deadlock )**。

![](https://gitee.com/veal98/images/raw/master/img/20200627145731.png)



> 🚩 当程序挂起时， 键入 `CTRL+\` , 将得到一个所有线程的列表。每一个线程有一个栈踪迹， 告诉你线程被阻塞的位置。

导致死锁的另一种途径是让第 i 个线程负责向第 i 个账户存钱，而不是从第 i 个账户取钱。 这样一来，有可能将所有的线程都集中到一个账户上，每一个线程都试图从这个账户中取出大 于该账户余额的钱。

还有一种很容易导致死锁的情况： 在 `SynchBankTest `程序中， 将 `signalAll `方法转换 为 `signal `, 会发现该程序最终会挂起（将 NACCOUNTS 设为 10 可以更快地看到结果）。 `signalAll `通知所有等待增加资金的线程， 与此不同的是 `signal`方法仅仅对一个线程解锁。如果该线程不能继续运行，所有的线程可能都被阻塞。

😞 遗憾的是，Java 编程语言中没有任何东西可以避免或打破这种死锁现象。必须仔细设计程序， 以确保不会出现死锁。

### ⑪ 线程局部变量 ThreadLocal 类

前面几节中， 我们讨论了在线程间共享变量的风险。**有时可能要避免共享变量， 使用 `ThreadLocal` 辅助类为各个线程提供各自的实例。** 

例如，`SimpleDateFormat `类不是线程安全的。 假设有一个静态变量：

```java
public static final SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
```

如果两个线程都执行以下操作： 

```java
String dateStamp = dateFormat.format(new Date());
```

结果可能很混乱，因为 `dateFormat `使用的内部数据结构可能会被并发的访问所破坏。当然可以使用同步，但开销很大； 或者也可以在需要时构造一个局部 `SimpleDateFormat `对象， 不过这也太浪费了。 

👍 要为每个线程构造一个实例，可以使用以下代码：

```java
public static final ThreadLocal<SimpleDateFormat> dateFormat = 
    ThreadLocal.withInitial(() -> new SimpleDateFormat("yyyy-MM-dd"));
```

![](https://gitee.com/veal98/images/raw/master/img/20200627151133.png)

要访问具体的格式化方法，可以调用： 

```java
String dateStamp = dateFormat.get().format(new Date());
```

即比之前多调用了一个 `get `方法。

**在一个给定线程中首次调用 `get `时， 会调用 `initialize `方法。在此之后， `get `方法会返回属于当前线程的那个实例。**

在多个线程中生成随机数也存在类似的问题。`java.util.Random `类是线程安全的。但是如果多个线程需要等待一个共享的随机数生成器， 这会很低效。 可以使用 `ThreadLocal` 辅助类为各个线程提供一个单独的生成器， 不过 Java SE 7 还另外 提供了一个便利类。只需要做以下调用：

```java
int random = ThreadLocalRandom.current().nextInt(upperBound);
```

`ThreadLocalRandom.current()` 调用会返回特定于当前线程的 `Random `类实例。

![](https://gitee.com/veal98/images/raw/master/img/20200627151108.png)

### ⑫ 锁测试与超时

线程在调用 `lock `方法来获得另一个线程所持有的锁的时候，很可能发生阻塞。应该更加谨慎地申请锁。**`tryLock `方法试图申请一个锁， 在成功获得锁后返回 `true`,  否则，立即返回 `false`, 而且线程可以立即离开去做其他事情。**

```java
if(mylock.trylock()){
    // now the thread owns the lock
    try{...}
    finally{
        mylock.unlock();
    }
} else{
    // do something else
}
```

可以调用 `tryLock `时，使用**超时参数**，像这样：

```java
if (myLock.tryLock(100, TineUnit.MILLISECONDS)){
    ......
}
```

`TimeUnit `是一 枚举类型，可以取的值包括 `SECONDS`、`MILLISECONDS`, `MICROSECONDS `和 `NANOSECONDS`。

`lock `方法不能被中断。如果一个线程在等待获得一个锁时被中断，中断线程在获得锁之前一直处于阻塞状态。如果出现死锁， 那么，lock 方法就无法终止。 

然而， 如果调用带有用超时参数的 `tryLock`, 那么如果线程在等待期间被中断，将抛出 `InterruptedException `异常。这是一个非常有用的特性，因为允许程序打破死锁。

<u>也可以调用 `lockInterruptibly `方法代替 `tryLock`。它就相当于一个超时设为无限的 `tryLock `方法</u>

![](https://gitee.com/veal98/images/raw/master/img/20200627152210.png)

👇 **在等待一个条件时， 也可以提供一个超时**：

```java
myCondition.await(100, TimeUnit.MILLISECONDS))
```

<u>如果一个线程被另一个线程通过调用 `signalAll `或 `signal `激活， 或者超时时限已达到，或者线程被中断， 那么 `await `方法将返回。</u> 

如果等待的线程被中断， `await `方法将抛出一个 `InterruptedException `异常。如果你希望出现这种情况时线程继续等待， 可以使用 `awaitUninterruptibly `方法代替 `await`。

![](https://gitee.com/veal98/images/raw/master/img/20200627152303.png)

### ⑬ 读/写锁 ReentrantReadWriteLock 

`java.util.concurrent.locks` 包定义了两个锁类， 

- `ReentrantLock `

- `ReentrantReadWriteLock `

**如果很多线程从一个数据结构读取数据而很少线程修改其中数据的话， 后者是十分有用的。**在这种情况下，允许对读者线程共享访问是合适的。当然，写者线程依然必须是互斥访问的。

![](https://gitee.com/veal98/images/raw/master/img/20200627153006.png)

⭐ **下面是使用读 / 写锁的必要步骤**：

- 构造一个 `ReentrantReadWriteLock` 对象：

  ```java
  private ReentrantReadWriteLock rwl = new ReentrantReadWriteLock():
  ```

-  抽取读锁和写锁：

  ```java
  private Lock readLock = rwl.readLock();
  private Lock writeLock = rwl.writeLock();
  ```

- 对所有的获取方法加读锁：

  ```java
  public double getTotalBalance(){
      readLock.lock();
      try { 
          . . . 
      } finally { 
          readLock.unlock(); 
      }
  }
  ```

- 对所有的修改方法加写锁：

  ```java
  public void transfer(. . .){
      writeLock.lock();
      try { 
          . . . 
      } finally { 
          writeLock.unlock(); 
      }
  }
  ```

  

### ⑭ 为什么弃用 stop 和 suspend 方法

初始的 Java 版本定义了一个 `stop` 方法用来终止一个线程， 以及一个 `suspend `方法用来阻塞一个线程直至另一个线程调用 `resume`。`stop` 和 `suspend `方法有一些共同点：都试图控制一 个给定线程的行为。

🚨 **`stop`、 `suspend `和 `resume `方法已经弃用**。`stop `方法天生就不安全，经验证明 `suspend `方法会经常导致死锁。

首先来看看 `stop `方法， 该方法终止所有未结束的方法， 包括 `run` 方法。当线程被终止，立即释放被它锁住的所有对象的锁。这会导致对象处于不一致的状态。

例如：假定 `TransferThread `在从一个账户向另一个账户转账的过程中被终止，钱款已经转出，却没有转入目标账户，现在银行对象就被破坏了。因为锁已经被释放，这种破坏会被其他尚未停止的线程观察到。 

**当线程要终止另一个线程时， 无法知道什么时候调用 `stop `方法是安全的， 什么时候导致对象被破坏**。因此，该方法被弃用了。

接下来， 看看 `suspend`方法有什么问题。与 `stop `不同，`suspend `不会破坏对象。但是， 如果用 `suspend `挂起一个持有一个锁的线程， 那么，该锁在恢复之前是不可用的。**如果调用 `suspend `方法的线程试图获得同一个锁， 那么程序死锁： <u>被挂起的线程等着被恢复，而将其挂起的线程等待获得锁</u>**。

## 6. 阻塞队列 BlockingQueue

现在，读者已经看到了形成 Java 并发程序设计基础的底层构建块。然而，<u>对于实际编程来说，应该尽可能远离底层结构。使用由并发处理的专业人士实现的较高层次的结构要方便得多、安全得多。</u>

对于许多线程问题， 可以通过使用一个或多个队列以优雅且安全的方式将其形式化。**生产者线程向队列插入元素， 消费者线程则取出它们**。<u>使用队列，可以安全地从一个线程向另一个线程传递数据。例如，考虑银行转账程序， 转账线程将转账指令对象插入一个队列中， 而不是直接访问银行对象。另一个线程从队列中取出指令执行转账。只有该线程可以访问该银行对象的内部。因此不需要同步。</u>

<u>当试图向队列添加元素而队列已满， 或是想从队列移出元素而队列为空的时候， **阻塞队列（BlockingQueue )** 导致线程阻塞</u>。在协调多个线程之间的合作时，阻塞队列是一个有用的 工具。工作者线程可以周期性地将中间结果存储在阻塞队列中。其他的工作者线程移出中间结果并进一步加以修改。队列会自动地平衡负载。如果第一个线程集运行得比第二个慢， 第二个线程集在等待结果时会阻塞。如果第一个线程集运行得快， 它将等待第二个队列集赶上来。

⭐ 表 14-1 给出了阻塞队列 `BlockingQueue `的核心方法：

```java
public interface BlockingQueue<E> extends Queue<E> {

    //将给定元素设置到队列中，如果设置成功返回true, 否则抛出异常。如果是往限定了长度的队列中设置值，推荐使用offer()方法。
    boolean add(E e);

    //将给定的元素设置到队列中，如果设置成功返回true, 否则返回false. e的值不能为空，否则抛出空指针异常。
    boolean offer(E e);

    //将元素设置到队列中，如果队列中没有多余的空间，该方法会一直阻塞，直到队列中有多余的空间。
    void put(E e) throws InterruptedException;

    //将给定元素在给定的时间内设置到队列中，如果设置成功返回true, 否则返回false.
    boolean offer(E e, long timeout, TimeUnit unit)
        throws InterruptedException;

    //从队列中获取值，如果队列中没有值，线程会一直阻塞，直到队列中有值，并且该方法取得了该值。
    E take() throws InterruptedException;

    //在给定的时间里，从队列中获取值，如果没有取到会抛出异常。
    E poll(long timeout, TimeUnit unit)
        throws InterruptedException;

    //获取队列中剩余的空间。
    int remainingCapacity();

    //从队列中移除指定的值。
    boolean remove(Object o);

    //判断队列中是否拥有该值。
    public boolean contains(Object o);

    //将队列中值，全部移除，并发设置到给定的集合中。
    int drainTo(Collection<? super E> c);

    //指定最多数量限制将队列中值，全部移除，并发设置到给定的集合中。
    int drainTo(Collection<? super E> c, int maxElements);
}
```

例如，下面的调用： 

```java
boolean success = q.offer(x, 100, TimeUnit.MILLISECONDS);
```

 尝试在 100 毫秒的时间内在队列的尾部插人一个元素。如果成功返回 `true `;  否则，达到超时时，返回 `false`。类似地，下面的调用： 

```java
Object head = q.poll(100, TimeUnit.MILLISECONDS)
```

 尝试用 100 毫秒的时间移除队列的头元素；如果成功返回头元素，否则，达到在超时时， 返回 `null`。

如果队列满， 则 `put `方法阻塞；如果队列空， 则 `take `方法阻塞。在不带超时参数时， `offer `和 `poll `方法等效。

🚩 `java.util.concurrent `包提供了阻塞队列的几个变种：

| 队列                  | 有界性             | 锁   | 数据结构   |
| --------------------- | ------------------ | ---- | ---------- |
| ArrayBlockingQueue    | bounded(有界)      | 加锁 | arrayList  |
| LinkedBlockingQueue   | optionally-bounded | 加锁 | linkedList |
| PriorityBlockingQueue | unbounded          | 加锁 | heap       |
| DelayQueue            | unbounded          | 加锁 | heap       |
| SynchronousQueue      | bounded            | 加锁 | 无         |
| LinkedTransferQueue   | unbounded          | 加锁 | heap       |
| LinkedBlockingDeque   | unbounded          | 无锁 | heap       |

- `LinkedBlockingQueue ` ：**基于链表实现的一个阻塞队列，容量是没有上边界的**，但是，也可以选择指定最大容量。`LinkedBlockingDeque `是一个**双端**的版本。
- `ArrayBlockingQueue` ：**基于数组实现的一个阻塞队列，在构造时需要指定容量，并且有一个可选的参数来指定是否需要公平性**。若设置了公平参数， 则那么等待了最长时间的线程会优先得到处理。<u>通常，公平性会降低性能，只有在确实非常需要时才使用它</u>。 
- `PriorityBlockingQueue `：以上 2 种队列都是先进先出队列，而 `PriorityBlockingQueue` 却不是，**它会按照元素的优先级对元素进行排序，按照优先级顺序出队，每次出队的元素都是优先级最高的元素**。注意，此阻塞队列为**无界阻塞队列**，即容量没有上限但是，如果队列是空的， 取元素的操作会阻塞。

- `DelayQueue `：基于`PriorityQueue`，一种延时阻塞队列，**`DelayQueue`中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素**。`DelayQueue`也是一个**无界队列**，<u>因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞</u>。

  包含实现 `Delayed `接口的对象：

  ```java
  public class DelayQueue<E extends Delayed> extends AbstractQueue<E>
  	implements BlockingQueue<E>{
      ......
      
      long getDelay(TimeUnit unit);
  	
      ......
  }
  ```

  `getDelay `方法返回对象的残留延迟。负值表示延迟已经结束。元素只有在延迟用完的情况下才能从 `DelayQueue `移除。还必须实现 `compareTo `方法。`DelayQueue `使用该方法对元素进行排序。

<br>

✍ **阻塞队列代码实例**：

使用阻塞队列来控制一组线程。程序在一个目录及它的所有子目录下搜索所有文件， 打印出包含指定关键字的行。

```java
import java.io.File;
import java.io.IOException;
import java.util.Scanner;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;

public class BlockingQueueTest {

    private static BlockingQueue<File> queue = new ArrayBlockingQueue<>(10); // 阻塞队列
    private static final File DUMMY = new File(""); // 空文件

    public static void main(String [] args){
        try (Scanner in = new Scanner(System.in)){
            System.out.print("Enter base directory (ex: /opt/jdk/src) : ");
            String directory = in.nextLine();
            System.out.print("Enter keyword (ex: java) : ");
            String keyword = in.nextLine();

            Runnable enumerator = () -> {
                try {
                    enumerate(new File(directory)); // 查询所有文件名
                    queue.put(DUMMY); // 队列中加入空文件，作为结束标志
                } catch (Exception e) {
                    //TODO: handle exception
                }
            };

            new Thread(enumerator).start(); // 启动查询文件名的一个线程

            // 同时启动 100 个搜索线程
            for(int i = 0; i <= 100; i++){
                Runnable searcher = () -> {
                    try {
                        boolean done = false;
                        while(!done){
                            File file = queue.take(); // 依次从队列中取出文件进行搜索
                            if(file == DUMMY){ // 如果遍历到队列的最后一个文件 DUMMY
                                queue.put(file);
                                done = true;
                            }
                            else {
                                search(file, keyword);
                            }
                        }
                    } catch (Exception e) {
                        //TODO: handle exception
                    }
                };

                new Thread(searcher).start(); // 启动搜索带有关键字的文件的一个线程
            }

        } catch (Exception e) {
            //TODO: handle exception
        }
    }

    /**
     * 递归的列举给定目录及其子目录下的所有文件名
     * @param directory
     * @throws InterruptedException
     */
    public static void enumerate(File directory) throws InterruptedException{
        File[] files = directory.listFiles();
        for(File file : files){
            if(file.isDirectory()) // 如果还有子目录，递归查询
                enumerate(file);
            else
                queue.put(file);
        }
    }
    
    /**
     * 根据指定的关键词查询相应的文件，并打印匹配行的相关内容
     * @param file
     * @param keyword
     * @throws IOException
     */
    public static void search(File file, String keyword) throws IOException{
        try (Scanner in = new Scanner(file,"UTF-8")){
            int lineNumber = 0;
            while(in.hasNextLine()){
                lineNumber ++; // 行号
                String line = in.nextLine();
                if(line.contains(keyword))
                    System.out.printf("%s:%d:%s%n", file.getPath(),lineNumber,line);
            }
        } catch (Exception e) {
            //TODO: handle exception
        }
    }
}
```

运行结果如下：

![](https://gitee.com/veal98/images/raw/master/img/20200627212043.png)

## 7. 线程安全的集合

如果多线程要并发地修改一个数据结构， 例如散列表， 那么很容易会破坏这个数据结构。例如，一个线程可能要开始向表中插入一个新元素。假定在调整散列表各个桶之间的链接关系的过程中， 被剥夺了控制权。如果另一个线程也开始遍历同一个链表，可能使用无效的链接并造成混乱， 会抛出异常或者陷人死循环。 

可以通过提供锁来保护共享数据结构， 但是选择线程安全的实现作为替代可能更容易些。当然，前一节讨论的**阻塞队列就是线程安全的集合**。在下面各小节中， 将讨论 Java 类库提供的另外一些线程安全的集合。

### ① 线程安全的 Map、List、Set

`java.util.concurrent` 包提供了映射 Map、 有序集 List 和队列 Set 的高效实现（线程安全）：`ConcurrentHashMap`、 `ConcurrentSkipListMap `、`ConcurrentSkipListSet `和 `ConcurrentLinkedQueue`。

![](https://gitee.com/veal98/images/raw/master/img/20200627214357.png)

这些集合使用复杂的算法，通过允许并发地访问数据结构的不同部分来使竞争极小化。

**与大多数集合不同，`size`方法不必在常量时间内操作。确定这样的集合当前的大小通常需要遍历。**

### ② ConcurrentHashMap 的原子更新

**`ConcurrentHashMap` 是 `HashMap` 的线程安全版本，内部使用了数组+链表+红黑树的结构来存储数据**。

实际上`ConcurrentHashMap`确实已经足够线程安全了。在使用 `ConcurrentHashMap` 进行写数据时，使用 `segment `类（继承了`ReentrantLock`）来加锁处理，这样我们完全不需要担心多线程并发的情况下底层链表数组会被破坏的情况（链接丢失或构成循环）。
**但是，如果加上我们自己的垃圾代码，这个完美的线程安全立刻就可以被破解** 😒 来看看下面的代码，需求是统计 `ArraysList `中每个单词出现的次数：

```java
List<String> words = new ArrayList<>(20);
words.add("......");//省略添加单词
Map<String,Long> map =new ConcurrentHashMap<>();
for (String word: words){
    Long oldValue = map.get(word);
    Long newValue = oldValue == null ? 1 : oldValue + 1;
    map.put(word,newValue);
}
```

<u>显然，上面的代码不是线程安全的，不能保证数据的原子性。可能会有另一个线程在同时更新同一个计数。</u>这就是我们今天要讲的重点：`ConcurrentHashMap` 如何进行原子更新。

> 📜 有些程序员很奇怪为什么原本线程安全的数据结构会允许非线程安全的操作。有以下两种完全不同的情况。
>
> - 如果多个线程修改一个普通的 `HashMap`，它们会破坏内部结构 （一个链表数组）。有些链接可能丢失， 或者甚至会构成循环，使得这个数据结构不再 可用。
>
> - 对于 `ConcurrentHashMap `绝对不会发生这种情况。在上面的例子中，`get `和 `put `代码不会破坏数据结构。不过，由于操作序列不是原子的，所以结果不可预知。

传统的做法是使用 `replace `操作， 它会以原子方式用一个新值替换原值，前提是之前没有其他线程把原值替换为其他值。必须一直这么做， 直到 `replace `成功：

```java
do{
    oldValue = map.get(word);
    newValue = oldValue == null ? 1 : oldValue + 1;
} while(!map.replace(word,oldValue,newValue));
```

或者， 可以使用一个 `ConcurrentHashMap<String, AtomicLong>`， 或者在 Java SE 8 中， 还可以使用 `ConcurrentHashMap<String, LongAdder> `。更新代码如下：

```java
// Absent是缺席的意思，就是如果map中不存在就初始化一个LongAdder进去，LongAdder()是原子类，保证下面加一操作的原子性
map.putIfAbsent(word, new LongAdder());
map.get(word).increment();
```

第一个语句确保有一个 `LongAdder ` 可以完成原子自增。由于 `putIfAbsent `返回映射的的值（可能是原来的值， 或者是新设置的值)， 所以可以组合这两个语句： 

```java
map.putIfAbsent(word, new LongAdder()).increment();
```

Java SE 8 提供了一些可以更方便地完成原子更新的方法。调用 `compute `方法时可以提供一个键和一个计算新值的函数。这个函数接收键和相关联的值（如果没有值，则为 `null`), 它会计算新值。例如，可以如下更新一个整数计数器的映射：

```java
map.compute(word, (k,v) -> v == null ? 1 : v + 1);
```

我们还可以这样写：

```java
map.computeIfAbsent(word, k -> new LongAdder()).increment();
```

### ③ 对 ConcurrentHashMap 的批操作

Java SE 8 为并发散列映射 `ConcurrentHashMap `提供了**批操作**，**即使有其他线程在处理映射，这些操作也能安全地执行**。<u>批操作会遍历映射，处理遍历过程中找到的元素。无须冻结当前映射的快照</u>。除非你恰好知道批操作运行时映射不会被修改， 否则就要把结果看作是映射状态的一个近似。

🚩 有 3 种不同的操作： 

- 搜索（`search`) ：为每个键或值提供一个函数，直到函数生成一个非 `null `的结果。然后搜索终止，返回这个函数的结果。 
- 归约（`reduce`)： 组合所有键或值， 这里要使用所提供的一个累加函数。 
- `forEach `：为所有键或值提供一个函数。

每个操作都有 4 个版本：

- `operation`: 处理键和值。 

- `operationKeys`: 处理键。 
- `operatioriValues`: 处理值。 
- `operatioriEntries`: 处理 `Map.Entry `对象。

🔰 对于上述各个操作， 需要指定一个参数化阈值（`threshold`)。**如果映射包含的元素多于这个阈值，就会并行完成批操作**。<u>如果希望批操作在一个线程中运行，可以使用阈 值` Long.MAX_VALUE`。如果希望用尽可能多的线程运行批操作，可以使用阈值 1</u>。

👁‍🗨 下面首先来看 `search`方法。有以下版本：

```java
public <U> U search(long parallelismThreshold,
                        BiFunction<? super K, ? super V, ? extends U> searchFunction) {
    if (searchFunction == null) throw new NullPointerException();
    return new SearchMappingsTask<K,V,U>
        (null, batchFor(parallelismThreshold), 0, 0, table,
         searchFunction, new AtomicReference<U>()).invoke();
}
```

```java
public <U> U searchKeys(long parallelismThreshold,
                            Function<? super K, ? extends U> searchFunction) {
    if (searchFunction == null) throw new NullPointerException();
    return new SearchKeysTask<K,V,U>
        (null, batchFor(parallelismThreshold), 0, 0, table,
         searchFunction, new AtomicReference<U>()).invoke();
}
```

```java
public <U> U searchValues(long parallelismThreshold,
                              Function<? super V, ? extends U> searchFunction) {
    if (searchFunction == null) throw new NullPointerException();
    return new SearchValuesTask<K,V,U>
        (null, batchFor(parallelismThreshold), 0, 0, table,
         searchFunction, new AtomicReference<U>()).invoke();
}
```

```java
public <U> U searchEntries(long parallelismThreshold,
                               Function<Map.Entry<K,V>, ? extends U> searchFunction) {
    if (searchFunction == null) throw new NullPointerException();
    return new SearchEntriesTask<K,V,U>
        (null, batchFor(parallelismThreshold), 0, 0, table,
         searchFunction, new AtomicReference<U>()).invoke();
}
```

例如， 假设我们希望找出第一个出现次数超过 1000 次的单词。需要搜索键和值：

```java
String result = map.search(threshold, (k,v) -> v > 1000 ? k : null);
```

`forEach` 方法有两种形式。第一个只为各个映射条目提供一个消费者函数， 例如：

```java
map.forEach(threshold,
			(k, v) -> System.out.println(k + " -> " + v));
```

第二种形式还有一个转换器函数， 这个函数要先提供， 其结果会传递到消费者：

```java
map.forEach(threshold, 
            (k,v) -> k + " -> " + v,  // 转换器
            System.out::println); // 消费者
```

<u>转换器可以用作为一个过滤器。**只要转换器返回 `null `, 这个值就会被悄无声息地跳过**</u>。 例如，下面只打印有大值的条目：

```java
map.forEach(threshold,
           (k,v) -> v > 1000 ? k + " -> " + v : null), // 过滤器
			System.out::println); // null 将不会传递到消费者
```

`reduce `操作用一个累加函数组合其输入。例如，可以如下计算所有值的总和：

```java
Long sum = map.reduceValues(threshold, Long::sum);
```

与 `forEach `类似，也可以提供一个转换器函数。可以如下计算最长的键的长度：

```java
Integer maxLength = map.reduceKeys(threshold,
                                  String::length, // 转换器
                                  Integer::max); // 累加器
```

转换器可以作为一个过滤器，通过返回 `null` 来排除不想要的输入。 例如，我们要统计多少个条目的值大于 1000：

```java
Long count = map.reduceValues(threshold,
                             v -> v > 1000 ? 1L : null,
                             Long :: sum);
```

> 📜 如果映射为空， 或者所有条目都被过滤掉， `reduce `操作会返回 `null`。如果只有一 个元素， 则返回其转换结果，不会应用累加器。

对于 `int`、 `long `和 `double `输出还有相应的特殊化操作， 分别有后缀 `ToInt`、 `ToLong `和 `ToDouble`。例如：

```java
public long reduceValuesToLong(long parallelismThreshold,
                               ToLongFunction<? super V> transformer,
                               long basis,
                               LongBinaryOperator reducer) {
    if (transformer == null || reducer == null)
        throw new NullPointerException();
    return new MapReduceValuesToLongTask<K,V>
        (null, batchFor(parallelismThreshold), 0, 0, table,
         null, transformer, basis, reducer).invoke();
}
```

需要把输入转换为一个基本类型值，并指定一个默认值和一个累加器函数。映射为空时返回默认值：

```java
long sum = map.reduceValuesToLong(threshold,
	Long::longValue, // Transformer to primitive type
	0, // Default value for empty map
	Long::sum); // Primitive type accumulator
```

### ④ 并发集视图（Set）

假设你想要的是一个大的线程安全的集而不是映射。**并没有一个 `ConcurrentHashSet `类**， 而且你肯定不想自己创建这样一个类。当然，可以使用 `ConcurrentHashMap `(包含“ 假” 值), 不过这会得到一个映射而不是集， 而且不能应用 `Set` 接口的操作。

**`ConcurrentHashMap` 中的静态 `newKeySet `方法会生成一个 `Set`**, 这实际上是 `ConcurrentHashMap<K,Boolean>` 的一个包装器。（所有映射值都为 `Boolean.TRUE`，不过因为为只是要把它用作一个集，所以并不关心具体的值）

```java
public static <K> KeySetView<K,Boolean> newKeySet() {
    return new KeySetView<K,Boolean>
        (new ConcurrentHashMap<K,Boolean>(), Boolean.TRUE);
}

public static <K> KeySetView<K,Boolean> newKeySet(int initialCapacity) {
    return new KeySetView<K,Boolean>
        (new ConcurrentHashMap<K,Boolean>(initialCapacity), Boolean.TRUE);
}
```

可以如下使用：

```java
Set<String> words = ConcurrentHashMap.<String>newKeySet();
```

当然， **如果已经有一个映射，可以使用 `keySet `方法生成这个映射的键集**。这个集是可变的。 如果删除这个集的元素，这个键（以及相应的值）会从映射中删除。不过，不能向键集增加 元素，因为没有相应的值可以增加。

```java
public KeySetView<K,V> keySet() {
    KeySetView<K,V> ks;
    return (ks = keySet) != null ? ks : (keySet = new KeySetView<K,V>(this, null));
}
```

Java SE 8 为 `ConcurrentHashMap `增加了第二个 `keySet `方 法，包含一个默认值，可以在为集增加元素时使用：

```java
public KeySetView<K,V> keySet(V mappedValue) {
    if (mappedValue == null)
        throw new NullPointerException();
    return new KeySetView<K,V>(this, mappedValue);
}
```

可以如下使用：

```java
Set<String> words = map.keySet(1L);
words.add("Java");
```

如果 `Java` 在 `words `中不存在， 则它会有一个值 1。

### ⑤ 较早的线程安全集合 Vector 和 Hashtable

从 Java 的初始版本开始，`Vector `和 `Hashtable `类就提供了**线程安全**的动态数组和散列表的实现。

<u>现在这些类被弃用了</u>， 取而代之的是**不是线程安全的 `AnayList `和 `HashMap `类**。而集合库中提供了不同的机制。<u>任何集合类都可以通过使用**同步包装器**（synchronization wrapper ) 变成线程安全的</u>：

```java
List<E> synchArrayList = Collections.synchronizedList(new ArrayList<E>());
Map<K,V> synchHashMap = Collections.synchronizedMap(new HashMap<E>());
```

结果集合的方法使用锁加以保护，提供了线程安全访问。

应该确保没有任何线程通过原始的非同步方法访问数据结构。最便利的方法是确保不保存任何指向原始对象的引用， 简单地构造一个集合并立即传递给包装器，像我们的例子中所做的那样。

最好使用 `java.util.concurrent` 包中定义的集合， 不使用同步包装器中的。

## 8. Callable、Future、FutureTask

### ① Callable

`Runnable `封装一个异步运行的任务，可以把它想象成为一个没有参数和返回值的异步方法。**`Callable `与 `Runnable `类似，但是有返回值**。`Callable `接口是一个参数化的类型， 只有一个方法 `call`。

```java
public interface Callable<V> {
    V call() throws Exception;
}
```

类型参数是返回值的类型。例如， `Callable<Integer> `表示一个最终返回 `Integer `对象的异步计算。

### ② Future

**`Future `保存异步计算的结果。可以启动一个计算，将 `Future` 对象交给某个线程，然后忘掉它**。`Future `对象的所有者在结果计算好之后就可以通过 `get` 获得它。

```java
public interface Future<V> {
    
    boolean cancel(boolean mayInterruptIfRunning);

    boolean isCancelled();

    boolean isDone();
	
    V get() throws InterruptedException, ExecutionException;

    V get(long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException;
}
```

![](https://gitee.com/veal98/images/raw/master/img/20200628163950.png)

第一个 `get `方法的调用被阻塞， 直到有可返回的值为止。如果在计算完成之前， 第二个 `get `方法的调用超时，拋出一个 `TimeoutException `异常。如果运行该计算的线程被中断，两个方法都将拋出 `InterruptedException`。如果计算已经完成， 那么 `get `方法立即返回。

如果计算还在进行，`isDone `方法返回 `false`;  如果完成了，则返回 `true`。

可以用 `cancel `方法取消该计算。如果计算还没有开始，它被取消且不再开始。如果计算处于运行之中，那么如果 `mayInterrupt` 参数为 `true`, 它就被中断。

### ③ FutureTask

**`FutureTask` 包装器是一种非常便利的机制， 可将 `Callable`转换成 `Future `和 `Runnable`, 它同时实现二者的接口**。

```java
public class FutureTask<V> implements RunnableFuture<V>{
    
    ......
        
    public FutureTask(Callable<V> callable) {
        if (callable == null)
            throw new NullPointerException();
        this.callable = callable;
        this.state = NEW;       // ensure visibility of callable
    }

    public FutureTask(Runnable runnable, V result) {
        this.callable = Executors.callable(runnable, result);
        this.state = NEW;       // ensure visibility of callable
    }
    
    ......
}
```

![](https://gitee.com/veal98/images/raw/master/img/20200628170533.png)

例如：

```java
public class MyCallable implements Callable<Integer> {
    public Integer call() {
        return 123;
    }
}

------------------------------
    
public static void main(String[] args) throws ExecutionException, InterruptedException {
    MyCallable mc = new MyCallable();
    FutureTask<Integer> ft = new FutureTask<>(mc);
    Thread thread = new Thread(ft); // It's a Runnable
    thread.start();
    System.out.println(ft.get()); // It'a Future
}
```

👀 下面的程序使用了这些概念。这个程序与前面那个寻找包含指定关键字的文件的例子相似。然而，现在我们仅仅计算匹配的文件数目。因此，我们需要一个长时间运行的任务，它返回一个整数值，一个 `Callable<Integer>` 的例子：

```java
class MatchCounter implements Callable<Integer>{
	public MatchCounter(File directory, String keyword) { 
    	......
    }
    public Integer call() {  // returns the number of matching files
        . . . 
    } 
}
```

然后我们利用 `MatchCounter `创建一个 `FutureTask `对象， 并用来启动一个线程。

```java
FutureTask<Integer> task = new FutureTask<Integer>(counter);
Thread t = new Thread(task);
t.start();
```

最后，我们打印结果：

```java
System.out.println(task.get() + " matching files.");
```

当然， **对 `get` 的调用会发生阻塞， 直到有可获得的结果为止**。

在 `call `方法内部， 使用相同的递归机制。 对于每一个子目录， 我们产生一个新的 `MatchCounter `并为它启动一个线程。此外， 把 `FutureTask `对象隐藏在 `ArrayList<Future<Integer>> `中。最后， 把所有结果加起来：

```java
for (Future<Integer> result : results)
	count += result.get();
```

每一次对 `get `的调用都会发生阻塞直到结果可获得为止。当然，线程是并行运行的， 因此， 很可能在大致相同的时刻所有的结果都可获得。

✍ 具体代码如下：

```java
package demo;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;
import java.util.concurrent.FutureTask;

public class FutureTest {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        System.out.println("Enter base directory (ex: E:/Codes): ");
        String directory = in.nextLine();
        System.out.println("Enter keyword (ex: Java): ");
        String keyword = in.nextLine();

        MathCounter counter = new MathCounter(new File(directory), keyword);
        FutureTask<Integer> task = new FutureTask<>(counter); // Runnable
        Thread t = new Thread(task);
        t.start();
        try {
            System.out.println(task.get() + " matching files."); // Callable
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }
    }
}

/**
 * 统计给定文件名下包含关键字的文件数目
 */
class MathCounter implements Callable<Integer>{
    private File directory;
    private String keyword;

    public MathCounter(File directory, String keyword){
        this.directory = directory;
        this.keyword = keyword;
    }

    /**
     * 返回符合条件的文件个数
     * @return
     * @throws Exception
     */
    @Override
    public Integer call() throws Exception {
        int count = 0;
        File[] files = directory.listFiles();
        List<Future<Integer>> results = new ArrayList<>();

        for(File file : files){
            if(file.isDirectory()){
                MathCounter counter = new MathCounter(file,keyword);
                FutureTask<Integer> task = new FutureTask<>(counter); // Runnable
                results.add(task);
                Thread t = new Thread(task);
                t.start(); // 对于每个文件都使用一个线程
            }
            else {
                if(search(file))
                    count ++;
            }
        }
        for(Future<Integer> result : results){
            count += result.get(); // Callable
        }
        return count;
    }

    /**
     * 查找文件中是否包含关键字
     * @param file
     * @return
     */
    public boolean search(File file){
        try {
            Scanner in = new Scanner(file, "UTF-8");

            boolean found = false; // 是否包含关键字
            while(!found && in.hasNextLine()){
                String line = in.nextLine();
                if(line.contains(keyword))
                    found = true;
            }
            return found;

        } catch (FileNotFoundException e) {
            e.printStackTrace();
            return false;
        }
    }
}
```

结果如下：

![](https://gitee.com/veal98/images/raw/master/img/20200628163534.png)

## 9. 执行器类 Executor

### ① Executor、ExecutorService、Executors

⭐ 首先区分一下这三个类：

- `Executor ` **顶级接口**：定义了一个接收 `Runnable` 对象的方法 `executor`：

  ```java
  public interface Executor {
      void execute(Runnable command);
  }
  ```

  该方法接收一个`Runable`实例，它用来执行一个任务（任务即一个实现了`Runnable`接口的类）。

- `ExecutorService` **接口**：继承了`Executor`接口并进行了扩展，**提供了更多的方法**，我们能够获得任务执行的状态并且可以获取任务的返回值。

- `Executors` **工具类**：提供了一系列工厂方法用于**创建线程池**，返回的线程池都实现了`ExecutorService`接口。

### ② 线程池 thread pool

构建一个新的线程是有一定代价的， 因为涉及与操作系统的交互。如果程序中创建了大量的生命期很短的线程，应该使用**线程池（ thread pool )**。

**一个线程池中包含许多准备运行的空闲线程**。将 `Runnable `对象交给线程池， 就会有一个线程调用 `run `方法。 **当 `run `方法退出 时，线程不会死亡，而是在池中准备为下一个请求提供服务**。

另一个使用线程池的理由是**减少并发线程的数目**。创建大量线程会大大降低性能甚至使虚拟机崩溃。如果有一个会创建许多线程的算法， 应该使用一个线程数 “固定的” 线程池以限制并发线程的总数。

`Executors `类有许多静态工厂方法用来构建线程池， 下表对这些方法进行了汇总：

![](https://gitee.com/veal98/images/raw/master/img/20200628164729.png)

先来看一下前 3 个方法。下一节我们讨论其余的方法。

- `newCachedThreadPool` 方法构建了一个线程池， 对于每个任务， <u>如果有空闲线程可用，立即让它执行任务，如果没有可用的空闲线程， 则创建一个新线程。**在线程空闲 60 s 之后终止线程**。</u>

  <img src="https://gitee.com/veal98/images/raw/master/img/20200628171312.png" style="zoom:80%;" />

- `newFixedThreadPool `方法构建一个具有**固定大小（由参数指定）**的线程池。 如果提交的任务数多于空闲的线程数， 那么把得不到服务的任务放 置到队列中。当其他任务完成以后再运行它们。

  <img src="https://gitee.com/veal98/images/raw/master/img/20200628171241.png" style="zoom:80%;" />

- `newSingleThreadExecutor `是一个退化了的**大小为 1** 的线程池： 由一个线程按照顺序执行每一个提交的任务。

  <img src="https://gitee.com/veal98/images/raw/master/img/20200628171217.png" style="zoom:80%;" />

**这 3 个方法返回实现了 `ExecutorService `接口的 `ThreadPoolExecutor `类的对象**。

可用下面的方法之一将一个 `Runnable `对象或 `Callable `对象提交给 `ExecutorService`:

```java
Future<?> submit(Runnable task) 
Future<T> submit(Runnable task, T result) 
Future<T> submit(Callable task)
```

该池会在方便的时候尽早执行提交的任务。调用 `submit `时，会得到一个 `Future `对象， 可用来查询该任务的状态。

- 第一个 `submit `方法返回一个`Future<?>`。可以使用这样一个对象来调用 `isDone`、 `cancel `或 `isCancelled`。但是， **`get `方法在完成的时候只是简单地返回 `null`**。 
- 第二个版本的 `submit `也提交一个 `Runnable`， 并且 **`Future `的 `get `方法在完成的时候返回指定的 `result `对象**。 
- 第三个版本的 `submit `提交一个 `Callable`, 并且返回的 `Future `对象将在计算结果准备好的 时候得到它。

**当用完一个线程池的时候， 调用 `shutdown`**。该方法启动该池的关闭序列。被关闭的执行器不再接受新的任务。**当所有任务都完成以后，线程池中的线程死亡**。

另一种方法是调用 **`shutdownNow`。该池取消尚未开始的所有任务并试图中断正在运行的线程。**

⭐ 下面总结了在使用连接池时应该做的事：

- 调用 `Executors `类中静态的方法 `newCachedThreadPool `或 `newFixedThreadPool`。 
- 调用 `submit `提交 `Runnable `或 `Callable `对象。 
- 如果想要取消一个任务， 或如果提交 `Callable `对象， 那就要保存好返回的 `Future `对象。 
- 当不再提交任何任务时，调用 `shutdown`。

✍ 例如，前面的程序例子产生了大量的生命期很短的线程， 每个目录产生一个线程。下面我们使用一个线程池来修改该程序：

```java
package demo;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.concurrent.*;

public class FutureTest {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        System.out.println("Enter base directory (ex: E:/Codes): ");
        String directory = in.nextLine();
        System.out.println("Enter keyword (ex: Java): ");
        String keyword = in.nextLine();

        ExecutorService pool = Executors.newCachedThreadPool(); // 创建线程池

        MathCounter counter = new MathCounter(new File(directory), keyword, pool);
        Future<Integer> result = pool.submit(counter);

        try {
            System.out.println(result.get() + " matching files.");
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }
        pool.shutdown(); // 关闭线程池
		
        // getLargestPoolSize 返回线程池在该执行器生命周期中的最大尺寸
        int largeestPoolSize = ((ThreadPoolExecutor) pool).getLargestPoolSize();
        System.out.println("largest pool size = " + largeestPoolSize);
    }
}

/**
 * 统计给定文件名下包含关键字的文件数目
 */
class MathCounter implements Callable<Integer>{
    private File directory;
    private String keyword;
    private ExecutorService pool; // 线程池
    private int count; // 文件个数

    public MathCounter(File directory, String keyword, ExecutorService pool){
        this.directory = directory;
        this.keyword = keyword;
        this.pool = pool;
    }

    /**
     * 返回符合条件的文件个数
     * @return
     * @throws Exception
     */
    @Override
    public Integer call() throws Exception {
        count = 0;
        File[] files = directory.listFiles();
        List<Future<Integer>> results = new ArrayList<>();

        for(File file : files){
            if(file.isDirectory()){
                MathCounter counter = new MathCounter(file,keyword,pool);
                Future<Integer> result = pool.submit(counter);
                results.add(result);
            }
            else {
                if(search(file))
                    count ++;
            }
        }
        for(Future<Integer> result : results){
            count += result.get();
        }
        return count;
    }

    /**
     * 查找文件中是否包含关键字
     * @param file
     * @return
     */
    public boolean search(File file){
        try {
            Scanner in = new Scanner(file, "UTF-8");

            boolean found = false; // 是否包含关键字
            while(!found && in.hasNextLine()){
                String line = in.nextLine();
                if(line.contains(keyword))
                    found = true;
            }
            return found;

        } catch (FileNotFoundException e) {
            e.printStackTrace();
            return false;
        }
    }
}
```

运行结果如下：

![](https://gitee.com/veal98/images/raw/master/img/20200628172808.png)

## 10. 同步器

`java.util.concurrent` 包含了几个能帮助人们管理相互合作的线程集的类见表 14-5。

![](https://gitee.com/veal98/images/raw/master/img/20200628174906.png)

### ① 信号量 Semaphore

**`Semaphore `类似于操作系统中的信号量，可以控制对互斥资源的访问线程数。**

概念上讲，一个信号量管理许多的许可证（permit)。为了通过信号量，线程通过调用 `acquire `请求许可。其实没有实际的许可对象， 信号量仅维护一个计数。许可的数目是固定 的，由此限制了通过的线程数量。其他线程可以通过调用 `release` 释放许可。而且，许可不是必须由获取它的线程释放。事实上，任何线程都可以释放任意数目的许可，这可能会增加许可数目以至于超出初始数目。

```java
public class Semaphore implements java.io.Serializable {
    .......
    public Semaphore(int permits) {
        sync = new NonfairSync(permits);
    }
    ......
}
```

💬 以下代码模拟了对某个服务的并发请求，每次只能有 3 个客户端同时访问，请求总数为 10。

```java
public class SemaphoreExample {

    public static void main(String[] args) {
        final int clientCount = 3;
        final int totalRequestCount = 10;
        Semaphore semaphore = new Semaphore(clientCount);
        ExecutorService executorService = Executors.newCachedThreadPool();
        for (int i = 0; i < totalRequestCount; i++) {
            executorService.execute(()->{
                try {
                    semaphore.acquire();
                    System.out.print(semaphore.availablePermits() + " ");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    semaphore.release();
                }
            });
        }
        executorService.shutdown();
    }
}
```

### ② 倒计时门栓 CountDownLatch

一个倒计时门栓（ `CountDownLatch `) 让一个线程集等待直到计数变为 0（每次调用 `countDown()` 方法会让计数器的值减 1，减到 0 的时候，那些因为调用 `await()` 方法而在等待的线程就会被唤醒）。**倒计时门栓是一次性的。一旦计数为 0, 就不能再重用了**。 

```java
public class CountdownLatchExample {

    public static void main(String[] args) throws InterruptedException {
        final int totalThread = 10;
        CountDownLatch countDownLatch = new CountDownLatch(totalThread);
        ExecutorService executorService = Executors.newCachedThreadPool();
        for (int i = 0; i < totalThread; i++) {
            executorService.execute(() -> {
                System.out.print("run..");
                countDownLatch.countDown();
            });
        }
        countDownLatch.await();
        System.out.println("end");
        executorService.shutdown();
    }
}

```

<img src="https://gitee.com/veal98/images/raw/master/img/20200628193827.png" style="zoom:80%;" />

一个有用的特例是计数值为 1 的门栓，实现一个一次只能通过一个线程的门。线程在门外等候，直到另一个线程将计数器值置为 0。

### ③ 障栅 CyclicBarrier

`CyclicBarrier `类实现了一个**集结点**（rendezvous) 称为**障栅**（ barrier)。考虑大量线程运行在一次计算的不同部分的情形。当所有部分都准备好时，需要把结果组合在一起。当一个线程完成了它的那部分任务后， 我们让它运行到障栅处。**一旦所有的线程都到达了这个障栅， 障栅就撤销， 线程就可以继续运行**。 下面是其细节。

首先， 构造一个障栅， 并给出参与的线程数：

```java
CyclicBarrier barrier = new CyclicBarrier(nthreads);
```

每一个线程做一些工作，完成后在障栅上调用 `await `

```java
public void run(){
    ...
    barrier.await();
    ...
}
```

`await `方法有一个可选的超时参数：

```java
barrier.await(100,TimeUnit.MILLISECONDS);
```

**如果任何一个在障栅上等待的线程离开了障栅， 那么障栅就被破坏了**（线程可能离开是因为它调用 `await `时设置了超时，或者因为它被中断了）。在这种情况下，所有其他线程的 `await `方法抛出 `BrokenBarrierException `异常。那些已经在等待的线程立即终止 `await `的调用。

可以提供一个可选的障栅动作（ barrier action ),  **当所有线程到达障栅的时候就会执行这 一动作**。

```java
// parties 指示计数器的初始值，barrierAction 在所有线程都到达屏障的时候会执行一次。
public CyclicBarrier(int parties, Runnable barrierAction) {
    if (parties <= 0) throw new IllegalArgumentException();
    this.parties = parties;
    this.count = parties;
    this.barrierCommand = barrierAction;
}
```

该动作可以收集那些单个线程的运行结果。

**障栅之所以被称为是循环的（cyclic),  是因为可以在所有等待线程被释放后被重用**。在这一点上，有别于 `CountDownLatch`, `CountDownLatch `只能被使用一次。

### ④ 交换器 Exchanger

当两个线程在同一个数据缓冲区的两个实例上工作的时候， 就可以使用交换器 ( Exchanger) 。典型的情况是， **一个线程向缓冲区填人数据， 另一个线程消耗这些数据。当它们都完成以后，相互交换缓冲区**。

### ⑤ 同步队列 SynchronousQueue

同步队列是一种将生产者与消费者线程配对的机制。当一个线程调用 `SynchronousQueue `的 `put `方法时，它会阻塞直到另一个线程调用 `take `方法为止，反之亦然。

**与 `Exchanger `的情 况不同， 数据仅仅沿一个方向传递，从生产者到消费者**。 

即使 `SynchronousQueue `类实现了 `BlockingQueue `接口， 概念上讲，它依然不是一个队列。它没有包含任何元素，它的 `size` 方法总是返回 0。

```java
public class SynchronousQueue<E> extends AbstractQueue<E>
    implements BlockingQueue<E>, java.io.Serializable {
    
    ......
        
    public int size() {
        return 0;
    }
    
    ......
}
```



## ✅ End

🎉 终于结束了~ 这节的内容实在是太多了。



## 📚 References

- 《Java 核心技术 - 卷 1 基础知识 - 第 10 版》

- [java面试题之Executor和Executors的区别](https://www.cnblogs.com/hujinshui/p/10367876.html)