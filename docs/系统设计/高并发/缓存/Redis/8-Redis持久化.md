# 🚍 Redis 持久化

---

Redis是一个内存数据库，数据保存在内存中，但是我们都知道内存的数据变化是很快的，也容易发生丢失。

![](https://gitee.com/veal98/images/raw/master/img/20200723164654.png)

为了避免内存中数据丢失，Redis提供了对持久化的支持，我们可以选择不同的方式将数据从内存中保存到硬盘当中，使数据可以持久化保存。

![](https://gitee.com/veal98/images/raw/master/img/20200723164757.png)

## 1. 持久化流程

既然redis的数据可以保存在磁盘上，那么这个流程是什么样的呢？

要有下面五个过程：

- 客户端向服务端发送写操作(数据在客户端的内存中)。

- 数据库服务端接收到写请求的数据(数据在服务端的内存中)。

- 服务端调用write这个系统调用，将数据往磁盘上写(数据在系统内存的缓冲区中)。

- 操作系统将缓冲区中的数据转移到磁盘控制器上(数据在磁盘缓存中)。

- 磁盘控制器将数据写到磁盘的物理介质中(数据真正落到磁盘上)。

这5个过程是在理想条件下一个正常的保存流程，但是在大多数情况下，我们的机器等等都会有各种各样的故障，这里划分了两种情况：

- Redis数据库发生故障，只要在上面的第三步执行完毕，那么就可以持久化保存，剩下的两步由操作系统替我们完成。

- 操作系统发生故障，必须上面5步都完成才可以。

在这里只考虑了保存的过程可能发生的故障，其实保存的数据也有可能发生损坏，需要一定的恢复机制，不过在这里就不再延伸了。现在主要考虑的是redis如何来实现上面5个保存磁盘的步骤。它提供了两种策略机制，也就是**RDB(Redis DataBase)** 和 **AOF(Append Only File)**。

## 2. RDB（Redis DataBase）

**RDB其实就是把数据以快照的形式保存在磁盘上**。❓ <u>什么是快照呢，你可以理解成把当前时刻的数据拍成一张照片保存下来。</u>

**RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘**。也是默认的持久化方式，这种方式是就是将内存中数据以快照的方式写入到二进制文件中,默认的文件名为 `dump.rdb`。

既然RDB机制是通过把某个时刻的所有数据生成一个快照来保存，那么就应该有一种**触发机制**，是实现这个过程。对于RDB来说，提供了三种机制：`save`、`bgsave`、自动化。我们分别来看一下

### ① save 触发方式

> 时间复杂度： O(N)， `N` 为要保存到数据库中的 key 的数量。

使用 `save `命令：

<img src="https://gitee.com/veal98/images/raw/master/img/20200723165922.png" style="zoom:80%;" />

`SAVE `命令执行一个**同步保存**操作，将当前 Redis 实例的所有数据快照 (snapshot) 以 RDB 文件的形式保存到硬盘。

该命令会阻塞当前Redis服务器，执行save命令期间，Redis不能处理其他命令，直到RDB过程完成为止。具体流程如下：

<img src="https://gitee.com/veal98/images/raw/master/img/20200723170133.png" style="zoom:80%;" />

一般来说，在生产环境很少执行 `SAVE `操作，因为它会阻塞所有客户端，这种方式显然不可取。

保存数据库的任务通常由 `BGSAVE `命令异步地执行。然而，如果负责保存数据的后台子进程不幸出现问题时， `SAVE `可以作为保存数据的最后手段来使用。

### ② bgsave 触发方式

> 时间复杂度： O(N)， `N` 为要保存到数据库中的 key 的数量。

在后台**异步(Asynchronously)**保存当前数据库的数据到磁盘。

<img src="https://gitee.com/veal98/images/raw/master/img/20200723170524.png" style="zoom:80%;" />

`bgsave` 命令执行之后立即返回 `OK` ，然后 Redis fork 出一个新子进程，原来的 Redis 进程(父进程)继续处理客户端请求，而子进程则负责将数据保存到磁盘，然后退出。

<img src="https://gitee.com/veal98/images/raw/master/img/20200723170301.png" style="zoom:80%;" />

具体操作是Redis进程执行fork操作创建子进程，RDB持久化过程由子进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短。基本上 Redis 内部所有的RDB操作都是采用 `bgsave `命令。

### ③ 自动化触发方式

**自动触发是由我们的配置文件来完成的。**

相关配置项如下：

- **save：**这里是用来配置触发 Redis的 RDB 持久化条件，也就是什么时候将内存中的数据保存到硬盘。比如 `save m n`。<u>表示 m 秒内数据集存在 n 次修改时，自动触发 `bgsave`</u>。

  比如说我们在配置文件中配置：

  ```xml
  save  60 5
  ```

  只要在 60s 内修改了 5 次 key，就会触发持久化操作

  不需要持久化，那么你可以注释掉所有的 `save` 行来停用保存功能。

- **stop-writes-on-bgsave-error ：**默认值为 `yes`。当启用了RDB且最后一次后台保存数据失败，Redis是否停止接收数据。这会让用户意识到数据没有正确持久化到磁盘上，否则没有人会注意到灾难（disaster）发生了。如果Redis重启了，那么又可以重新开始接收数据了

- **rdbcompression ：**默认值是 `yes`。对于存储到磁盘中的快照，可以设置是否进行压缩存储。

- **rdbchecksum ：**默认值是 `yes`。在存储快照后，我们还可以让redis使用CRC64算法来进行数据校验，但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能。

- **dbfilename ：**设置快照的文件名，默认是 `dump.rdb`

- **dir：**设置快照文件的存放路径，这个配置项一定是个目录，而不能是文件名。

### ④ RDB 优缺点

**优点**：

- RDB文件紧凑，**全量备份**，非常适合用于进行备份和灾难恢复。
- 生成RDB文件的时候，redis主进程会fork()一个子进程来处理所有保存工作，主进程不需要进行任何磁盘IO操作。
- **RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快**。

**缺点**：

- 需要一定的时间间隔进程操作！如果 redis 意外宕机了，这个**最后一次修改数据就没有了**
- **fork 进程的时候，会占用一定的内容空间**

## 3. AOF（Append Only File）

全量备份总是耗时的，有时候我们提供一种更加高效的方式 AOF，工作机制很简单，redis 会将每一个收到的写命令都通过 `write `函数追加到文件 `appendonly.aof` 中。

```xml
# 默认是不开启的，我们需要手动进行配置, 我们只需要将 appendonly 改为 yes就开启了
appendonly yes
```

💡 通俗的理解就是日志记录。**将我们的所有命令都记录下来，恢复的时候就把这个文件全部在执行一遍。**

### ① AOF 运行原理

<img src="https://gitee.com/veal98/images/raw/master/img/20200723172621.png" style="zoom:80%;" />

每当有一个写命令过来时，就直接保存在我们的AOF文件中。

### ② 文件重写原理

**AOF 的方式也同时带来了另一个问题。持久化文件会变的越来越大**。

<img src="https://gitee.com/veal98/images/raw/master/img/20200723173648.png" style="zoom: 67%;" />

如果 aof 文件大于 64m， redis 提供了 `bgrewriteaof `命令，将内存中的数据以命令的方式保存到临时文件中，同时会 fork 出一条新进程来将文件重写。

<img src="https://gitee.com/veal98/images/raw/master/img/20200723173122.png" style="zoom:80%;" />

重写 AOF 文件的操作，并没有读取旧的 AOF 文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的 AOF 文件，这点和快照有点类似。

### ③ AOF 的三种触发机制

- 每次修改同步 `always`：同步持久化，每次更新操作后调用 fsync() 将数据写到磁盘，性能较差但数据完整性比较好

- 每秒同步 `everysec`：异步操作，每秒记录。可能会丢失这1s的数据

- 不同步 `no`：从不同步，等操作系统进行数据缓存同步到磁盘

```xml
# 指定更新日志条件，共有 3 个可选值
appendfsync everysec 
```

### ④ AOF 的优缺点

**优点**：

- AOF 可以更好的保护数据不丢失，一般AOF会每隔1秒，通过一个后台线程执行一次 `fsync `操作，最多丢失1秒钟的数据。
- AOF 日志文件没有任何磁盘寻址的开销，写入性能非常高，文件不容易破损。
- AOF 日志文件即使过大的时候，出现后台重写操作，也不会影响客户端的读写。
- AOF 日志文件的命令通过非常可读的方式进行记录，这个特性非常适合做灾难性的误删除的紧急恢复。比如某人不小心用 `flushall `命令清空了所有数据，只要这个时候后台 `rewrite` 还没有发生，那么就可以立即拷贝AOF文件，将最后一条 `flushall `命令给删了，然后再将该AOF文件放回去，就可以通过恢复机制，自动恢复所有数据

**缺点**：

- 相对于数据文件来说，AOF 远远大于 RDB，修复的速度也比 RDB慢
- AOF 运行效率也要比 RDB慢，所以 Redis 默认的配置就是 RDB持久化

## 📚 References

- [【狂神说Java】Redis最新超详细版教程通俗易懂](https://www.bilibili.com/video/BV1S54y1R7SB?from=search&seid=3325634079268895938)

- [详解Redis中两种持久化机制RDB和AOF](https://baijiahao.baidu.com/s?id=1654694618189745916&wfr=spider&for=pc)

  