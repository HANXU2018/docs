# ⛲ 随机化算法

---

![](https://gitee.com/veal98/images/raw/master/img/20201201212043.png)

## 1. 什么是随机化算法

前面各章讨论的算法的每个计算步骤都是确定的，而随机化算法允许**算法在执行过程中随机地选择下一个计算步骤**。

随机化算法的一个基本特征就是：**同一随机化算法对同一实例求解两次可能得到完全不同的结果**。

> 💡 对比**确定性算法**：
>
> - 输入确定
> - 则对这个特定输入的每次运行过程是可重复的，运行结果是一样的
> - 比如，对于输入<6,4,5,8,9,3>，正确的插入排序算法对这个输入，每次的运行过程是一样的，运行结果也是一样的

💧 在随机算法中：

- 不要求算法对所有可能的输入均正确计算，只要求出现错误的可能性小到可以忽略的程度
- 也不要求对同一输入，算法每次执行时都给出相同的结果

🌞 随机算法的优点：

- 对于某一给定的问题，随机算法所需的时间与空间复杂度，往往比当前已知的、最好的确定性算法要好（**减少时间/空间复杂度**）
- 到目前为止设计出来的各种随机算法，无论是从理解上还是实现上，都是极为简单的（**容易理解**）
- 随机算法**避免了构造最坏情况的例子**

🌙 一般情况下，可将随机化算法分为以下四类：

- `数值随机化算法`
- `舍伍德算法 Sherwood`
- `拉斯维加斯算法 Las Vegs`
- `蒙特卡罗算法 Monte Carlo`

接下来我们将详细介绍这四种算法 👇

## 2. 随机数

随机数在随机化算法设计中扮演着重要的角色。不过，在目前的计算机中，无法产生真正的随机数，因此在随机算法中使用的随机数都是一定程度上随机的，即**伪随机数**。

产生伪随机数的常用方法 — **线性同余法**，由线性同余法产生的随机序列 $a_1,a_2,...a_ n,...$ 满足：

<img src="https://gitee.com/veal98/images/raw/master/img/20201201102257.png" style="zoom:50%;" />

其中，$b >= 0, c >= 0, d >= m$。`d` 为该**随机序列的种子**。<u>如何选取 b、c 和 m 直接关系到所产生的随机序列的随机性能</u>。

> 💡 **随机序列**：
>
> - 概率相等 (均匀随机)
> - 不可预测
> - 不可重现

```java
// Java 中的 Random 类
public Random(long seed) {
        if (getClass() == Random.class)
            this.seed = new AtomicLong(initialScramble(seed));
        else {
            // subclass might have overriden setSeed
            this.seed = new AtomicLong();
            setSeed(seed);
        }
    }
```

## 3. 数值随机化算法

<img src="https://gitee.com/veal98/images/raw/master/img/20201201101547.png" style="zoom:44%;" />

## 4. 蒙特卡罗算法 Monte Carlo

### ① 算法概念

<img src="https://gitee.com/veal98/images/raw/master/img/20201201101640.png" style="zoom:44%;" />

- 通常**不能保证计算出来的结果总是正确的，一般只能断定所给解的正确性不小于 `p`**（ 1/2 ＜ p ＜ 1）
- 通过算法的反复执行（即以增大算法的执行时间为代价），能够使发生错误的概率小到可以忽略的程度
- 由于每次执行的算法是独立的，故 k 次执行**均**发生错误的概率为 $(1-p)^k$

在**不允许发生错误**的应用中（e.g. 人造飞船、电网控制等），Monte Carlo 算法**不可以**使用。

若**允许小概率出错**的话，Monte Carlo 算法比 Las Vegas 算法要**节省许多时间**，是人们常常采用的方法

### ② 实例：Testing String Equality

**【问题描述】**：设 A 处有一个长字符串 x（e.g. 长度为 $10^6$），B 处也有一个长字符串 y，A 将 x 发给 B，由 B 判断是否有 x=y

**【解题思路】**：

- 首先由 A 发一个 x 的长度给 B，若长度不等，则 x≠y

- 若长度相等，则采用 “**取指纹**” 的方法：

  > 💡 常用的指纹：
  >
  > - 令 `I(x)` 是 x 的编码，取 `Ip(x) = I(x) (mod p)` 作为 x 的指纹
  > - 这里的 p 是一个小于 M 的**素数**，M 可根据具体需要调整

  - A 对 x 进行处理，取出 x 的“指纹”，然后将 x 的“指纹” 发给 B

  - 由 B 检查 x 的 “指纹” 是否等于 y 的“指纹”

  - **若取 k 次“指纹”（每次取法不同），每次两者结果均相同，则认为 x 与 y 是相等的**

  - **随着 k 的增大，误判率可趋于 0**

    > 💡 **误判率 P[failure]**：如果 `Ip(x) = Ip(y)` 而 `x ≠ y`，则称此种情况为一个误匹配 
    >
    > 若总是随机地去取一个小于 M 的素数 p，则对于给定的 x 和 y：
    >
    > `P[failure] = 使得 Ip(x) = Ip(y) 但 x ≠ y 的素数 p 的个数 ／ 小于 M 的素数的总个数`

### ③ 实例：主元素/多数元素问题

> 👉 [169. 多数元素 - 力扣（LeetCode）](https://leetcode-cn.com/problems/majority-element/)，该题的确定解其实用的是二分查找算法

**【问题描述】**：设 `T[1:n]` 是一个含有 n 个元素的数组。当 `|{i|T[i]=x}|>n/2` 时，称元素 x 是数组 T 的主元素（也就是说该元素的个数超过数组总个数的一半）

**【解题思路】**：

```java
// 判定主元素的蒙特卡罗算法
public static boolean Majority(int[]t, int n){
    rnd = new Random();
    int i=rnd.random(n)+1;
    int x=t[i];    // 随机选择数组元素
    int k=0;
    // 该随机元素在数组中的个数
    for (int j=1;j<=n;j++){
        if (t[j]==x) 
            k++;
    }
    return (k > n/2);  // k > n/2 时 t 含有主元素
}
```

由于数组的非主元素个数小于 n/2，因此上述算法返回 `false` 的概率小于 1/2。通俗来说，**如果数组中含有主元素，则算法有大于 1/2 的概率返回 `true`，否则返回 `false`**

当然，实际使用中，50% 的错误概率是不可容忍的，我们可以**重复调用上述算法**将错误概率降低到可接受的范围内：

<img src="https://gitee.com/veal98/images/raw/master/img/20201201122627.png" style="zoom:50%;" />

<img src="https://gitee.com/veal98/images/raw/master/img/20201201123015.png" style="zoom:45%;" />

<img src="https://gitee.com/veal98/images/raw/master/img/20201201123149.png" style="zoom: 45%;" />

## 5. 拉斯维加斯算法 Las Vegs

### ① 算法概念

<img src="https://gitee.com/veal98/images/raw/master/img/20201201101816.png" style="zoom:43%;" />

- 在少数应用中，**可能出现求不出解的情况**（💡 通常采用 `bool` 型函数表示拉斯维加斯型算法，当算法找到一个解时，返回 `true`。典型调用形式 `bool success = LV(x,y)`，其中 `x` 是输入参数，当 `success` 的值为 `true `时，`y` 返回问题的解）

- **一旦找到一个解，这个解一定是正确的**

- **在求不出解时，需再次调用算法进行计算，直到获得解为止**（当 `success` 的值为 `false` 时，算法未能找到问题的解，此时可对同一实例再次独立地调用相同的算法）

  <img src="https://gitee.com/veal98/images/raw/master/img/20201201110716.png" style="zoom:45%;" />

- 对于此类算法，主要是分析算法的时间复杂度的期望值，以及调用一次产生失败（求不出解）的概率

### ② 实例：找第 k 小元素

**【题目描述】**：在无序的 n 个数中找出第 k 小的元素

**【解题思路】**：

- 在 n 个数中随机的找一个数 `A[i] = x`, 然后将其余 n-1 个数与 x 比较，分别放入三个数组中：S1(元素均 < x), S2 (元素均 =x ), S3 (元素均＞x)
- 若 `|S1|≥k` ，则调用 `Select(k,S1)` （选择 S1 数组中的第 k 个元素）
- 若 `（|S1|+|S2|）≥k`，则第 k 小的元素就是 x
- 否则就有 `（|S1|+|S2|）＜ k`，此时调用 `Select(k-|S1|-|S2|,S3)`

### ③ 实例：Random Sampling

**【题目描述】**：给定 n 个元素（为简单起见，设为1，2，…n），要求从 n 个数中随机地选取 m 个数（m≤n）

**【解题思路】**：可以**用一个长为 n 的布尔数组 `B` 来标识 `i` 是否被选中**。初始时均表为“未选中”。然后随机产生〔1，n〕之间的一个整数 i，若 `B[i]` 为“未选中”，则将 `i` 加入被选中队列，同时把 `B[i]` 标识为“已选中”。反复执行直到 m 个不同的数全部被选出为止。

**上述算法存在的问题**：

- 1）当 n 和 m 很接近时，产生最后几个随机数的时间可能很长（有95％以上的可能性是已选中的数）

  **改进方法**：当 `m>n/2` 时，先生成 `(n-m)`个随机数，这样剩下的 m 个数就是我们所需要的随机数

- 2）当 n 与 m 相比大很多时（例：$n﹥m^2$），布尔数组 B 对空间浪费很多

  **改进方法**：用一个允许冲突的、长为 m 的**散列表**，来存放产生的随机数。产生一个数后，看其是否在散列表中：若不在则将其加入，若已在则抛弃该数，再去产生下一个数

## 6. 舍伍德算法 Sherwood

<img src="https://gitee.com/veal98/images/raw/master/img/20201201101919.png" style="zoom:43%;" />

**如果某个问题已经有了一个平均情况下较好的确定性算法，但是该算法在最坏情况下效率不高（比如快排的平均时间复杂度为 $O(nlogn)$，而当数组基本有序的最坏情况下，时间复杂度达到 $O(n^2)$）**，此时引入一个随机数发生器（通常是服从均匀分布，根据问题需要也可以产生其他的分布），可将一个确定性算法改成一个随机算法，使得对于任何输入实例，该算法在概率意义下都有很好的性能

<u>其实对于快速排序来说，将其改造成**舍伍德型快速排序**，就是将其基准的定位方法，由固定的左边第一个数，改成随机的一个数，将这个随机数与左边第一个数交换，并作为基准</u>

## 📚 References

- 《算法导论 — 第 3 版 机械工业出版社》
- 《计算机算法与分析 王晓东 - 第5版》