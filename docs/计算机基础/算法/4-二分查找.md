# 🧀 二分查找

---

> 🔈 **二分查找其实也是使用了分治法的思想**，由于题目较多，所以此处单独拎出来讲解

## 1. 二分查找基本思想

二分查找的**基本思想**是将 n 个元素分成大致相等的两部分，取 $a[n/2]$ 与 x 做比较：

- 如果 $x=a[n/2]$ , 则找到 x , 算法中止
- 如果 $x<a[n/2]$ , 则只需要在数组 a 的左半部分继续搜索 x
- 如果 $x>a[n/2]$ , 则只需要在数组 a 的右半部分继续搜索 x

## 2. 二分查找时间复杂度

**时间复杂度**即是 while 循环的次数。

总共有 n 个元素，渐渐跟下去就是 n, n/2 , n/4 ,.... $n/2 ^ k$（接下来操作元素的剩余个数），其中 k 就是循环的次数

由于 $n/2^k$ 取整后 >= 1

即令 $n/2^k=1$

可得 $k=log2n$,（以2为底，n的对数）

所以**时间复杂度可以表示 $O(n)=O(log_2n)$ 或者 $O(n)=O(logn)$**

## 3. 二分查找模板 ⭐

一般而言，当一个题目出现以下特性时，你就应该立即联想到它可能需要使用二分查找：

- **待查找的数组有序或者部分有序**

- 要求时间复杂度低于 `O(n)`，或者直接要求时间复杂度为 `O(log n)`

二分查找有很多种变体，使用时需要注意查找条件，判断条件和左右边界的更新方式，三者配合不好就很容易出现死循环或者遗漏区域，本篇中我们将介绍常见的几种查找方式的模板代码，包括：

- 标准的二分查找
- 二分查找左边界
- 二分查找右边界
- 二分查找左右边界
- 二分查找极值点

### ① 标准的二分查找

#### 📜 对应的 LeetCode

|                            🎯 题解                            | 🎲 难度 |
| :----------------------------------------------------------: | :----: |
| [349 - 两个数组的交集](计算机基础/算法/LeetCode/二分查找/349-两个数组的交集.md) |   😎    |
| [1237 - 找出给定方程的正整数解](计算机基础/算法/LeetCode/二分查找/1237-找出给定方程的正整数解.md) |   😎    |
| [704 - 二分查找](计算机基础/算法/LeetCode/二分查找/704-二分查找.md) |   😎    |
| [374 - 猜数字大小](计算机基础/算法/LeetCode/二分查找/374-猜数字大小.md) |   😎    |
| [69 - x 的平方根](计算机基础/算法/LeetCode/二分查找/69-x的平方根.md) |   😎    |

#### 模板详解

首先给出标准二分查找的模板：这个场景是最简单的，也是大家最熟悉的，即搜索一个数，如果存在，返回其索引，否则返回 -1。

```java
// 二分查找某个数
public int binarySearch(int[] nums, int target) {
    int left = 0;
    int right = nums.length - 1; 
    while (left <= right) { // 注意
        int mid = left + ((right - left) >> 1);
        if (nums[mid] == target) 
            return mid;
        else if (nums[mid] > target)
            right = mid - 1; 
        else // (nums[mid] < target)
            left = mid + 1; 
    }
    return -1;
}
```

- 循环条件： `left <= right`
- 中间位置计算： `mid = left + ((right -left) >> 1)` （ 位运算 `>> 1`  即 除法运算 `/ 2`）
- 左边界更新：`left = mid + 1`
- 右边界更新： `right = mid - 1`
- 返回值： `mid` 或 `-1`

🚨 这里有几点需要注意：

🔸 **① 为什么 while 循环的条件是 <=，而不是 < ？**

答：因为初始化 `right` 的赋值是 `nums.length - 1`，即最后一个元素的索引，而不是 `nums.length`。

这二者可能出现在不同功能的二分查找中，区别是：前者相当于两端都闭区间 `[left, right]`，后者相当于左闭右开区间 `[left, right)`，因为索引大小为 `nums.length` 是越界的。

我们这个算法中使用的是前者 `[left, right]` 两端都闭的区间。**这个区间其实就是每次进行搜索的区间**。

什么时候应该停止搜索呢？当然，找到了目标值的时候可以终止：

```java
    if(nums[mid] == target)
        return mid;
```

但如果没找到，就需要 while 循环终止，然后返回 -1。那 while 循环什么时候应该终止？**搜索区间为空的时候应该终止**，意味着你没得找了，就等于没找到嘛。

`while(left <= right)` 的终止条件是 `left == right + 1`，写成区间的形式就是 `[right + 1, right]`，或者带个具体的数字进去 `[3, 2]`，可见**这时候区间为空**，因为没有数字既大于等于 3 又小于等于 2 。所以这时候 while 循环终止是正确的，直接返回 -1 即可。

`while(left < right)` 的终止条件是 `left == right`，写成区间的形式就是 `[left, right]`，或者带个具体的数字进去 `[2, 2]`，**这时候区间非空**，还有一个数 2，但此时 while 循环终止了。也就是说这区间 `[2, 2]` 被漏掉了，索引 2 没有被搜索，如果这时候直接返回 -1 就是错误的。

💡 当然，如果你非要用 `while(left < right)` 也可以，我们已经知道了出错的原因，打个补丁好了：

```java
    //...
    while(left < right) {
        // ...
    }
    return nums[left] == target ? left : -1; // 判断 nums[left] 和 nums[right] 一样，因为最后循环终止的时候 left == right
```

🔸 **② 计算 mid 时需要防止溢出**

`left + ((right -left) >> 1)` 其实和 `(left + right) / 2`是等价的，这样写的目的一个是为了防止 `(left + right)`出现溢出，另外用位运算替代除法提升性能。

`left + ((right -left) >> 1)` 对于目标区域长度为奇数而言，是处于正中间的，对于长度为偶数而言，是中间偏左的。因此左右边界相遇时，只会是以下两种情况：

- `left/mid` , `right` ( left, mid 指向同一个数，right 指向它的下一个数)
- `left/mid/right` （ left, mid, right 指向同一个数）

即<u>因为`mid`对于长度为偶数的区间总是偏左的，所以当区间长度小于等于2时，`mid` 总是和 `left`在同一侧。</u>

### ② 二分查找左边界

上述算法自然是无法应用到所有场景的，比如说给你有序数组 `nums = [1,2,2,2,3]`，`target` 为 2，此算法返回的索引是 2。但是如果我<u>想得到 `target` 的左侧边界，即索引 1，或者我想得到 `target` 的右侧边界，即索引 3</u>，这样的话上述标准形式的二分查找算法是无法处理的。

**先从二分查找左边界说起**：利用二分法寻找左边界是二分查找的一个变体，应用它的题目常常有以下几种特性之一：

- 数组有序，但包含重复元素
- 数组部分有序，且不包含重复元素
- 数组部分有序，且包含重复元素

#### Ⅰ 左边界查找类型 1

##### 📜 对应的 LeetCode

|                            🎯 题解                            | 🎲 难度 |
| :----------------------------------------------------------: | :----: |
| [1351 - 统计有序矩阵中的负数](计算机基础/算法/LeetCode/二分查找/1351-统计有序矩阵中的负数.md) |   😎    |
| [278 - 第一个错误的版本](计算机基础/算法/LeetCode/二分查找/278-第一个错误的版本.md) |   😎    |
| [153 - 寻找旋转排序数组中的最小值](计算机基础/算法/LeetCode/二分查找/153-寻找旋转排序数组中的最小值.md) |   👻    |

##### 模板详解

左边界查找的第一种类型用于上述的第一种和第二种情况：<u>数组有序，但包含重复元素 或者 数组部分有序，且不包含重复元素</u>

<img src="https://gitee.com/veal98/images/raw/master/img/20200926161222.png" style="zoom:50%;" />

<u>**既然要寻找左边界，搜索范围就需要从右边开始，不断往左边收缩**，也就是说即使我们找到了`nums[mid] == target`, 这个`mid`的位置也不一定就是最左侧的那个边界，我们还是要向左侧查找，所以我们在`nums[mid]`偏大或者 `nums[mid]`就等于目标值的时候，继续收缩右边界</u>，算法模板如下：

```java
// 二分查找某个数的左边界
public int binarySearch(int[] nums, int target) {
    int left = 0;
    int right = nums.length - 1;
    while (left < right) { // 注意
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    return nums[left] == target ? left : -1;
}
```

- 循环条件： `left < right`
- 中间位置计算： `mid = left + ((right -left) >> 1)`
- 左边界更新：`left = mid + 1`
- 右边界更新： `right = mid`
- 返回值： `nums[left] == target ? left : -1`

🚨 与标准的二分查找不同：

**① 这里的右边界的更新是 `right = mid`，因为我们需要在找到目标值后，继续向左寻找左边界。**

**② 这里的循环条件是 `left < right` 而不是 `<=`：**

<u>因为在最后`left`与`right`相邻的时候，`mid`和`left`处于相同的位置(前面说过，`mid`偏左)，则下一步，无论怎样，`left`, `mid`, `right`都将指向同一个位置，如果此时循环的条件是`left <= right`，则我们需要再进入一遍循环，此时，如果`nums[mid] < target`还好说，循环正常终止；否则，我们会令`right = mid`，这样并没有改变`left`,`mid`,`right`的位置，将进入死循环。</u>

事实上，我们只需要遍历到`left`和`right`相邻的情况就行了，因为这一轮循环后，无论怎样，`left`,`mid`,`right`都会指向同一个位置，而如果这个位置的值等于目标值，则它就一定是最左侧的目标值；如果不等于目标值，则需要再多做一次判断，因为这个索引是我们漏掉的（上文 <u>标准的二分查找 ①</u> 中已有详细说明）：

```java
return nums[left] == target ? left : -1;
```

#### Ⅱ 左边界查找类型 2

##### 📜 对应的 LeetCode

|                            🎯 题解                            | 🎲 难度 |
| :----------------------------------------------------------: | :----: |
| [154 - 寻找旋转排序数组中的最小值 II](计算机基础/算法/LeetCode/二分查找/154-寻找旋转排序数组中的最小值II.md) |   👽    |

##### 模板详解

左边界查找的第二种类型适用于上述的第三种情况：<u>数组部分有序且包含重复元素</u>：

<img src="https://gitee.com/veal98/images/raw/master/img/20200926152151.png" style="zoom: 67%;" />

这种条件下在我们向左收缩的时候，不能简单的令 `right = mid`，因为有重复元素的存在，这会导致我们有可能遗漏掉一部分区域，此时向左收缩只能采用比较保守的方式，代码模板如下：

```java
// 二分查找某个数的左边界
public int binarySearch(int[] nums, int target) {
    int left = 0;
    int right = nums.length - 1;
    while (left < right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid;
        } else { // nums[mid] == target
            right--;
        }
    }
    return nums[left] == target ? left : -1;
}
```

<u>它与类型 1 的唯一区别就在于对右侧值的收缩更加保守。这种收缩方式可以有效地防止我们一下子跳过了目标边界从而导致了搜索区域的遗漏。</u>

不理解的话可以看一下这个题目的题解 👉 [154 - 寻找旋转排序数组中的最小值 II — Hard](计算机基础/算法/LeetCode/二分查找/154-寻找旋转排序数组中的最小值II.md)

### ③ 二分查找右边界

有了寻找左边界的分析之后，再来看寻找右边界就容易很多了，毕竟左右两种情况是对称的，关于使用场景这里就不再赘述了，大家对称着理解就好。我们直接给出**右边界查找类型 Ⅰ** 的模板代码（<u>数组有序，但包含重复元素 或 数组部分有序，且不包含重复元素</u>）：

```java
// 二分查找某个数的右边界
public int binarySearch(int[] nums, int target) {
    int left = 0;
    int right = nums.length - 1;
    while (left < right) {
        int mid = left + ((right - left) / 2) + 1;
        if (nums[mid] > target) {
            right = mid - 1;
        } else {
            left = mid;
        }
    }
    return nums[right] == target ? right : -1;
}
```

- 循环条件： `left < right`
- 中间位置计算： `mid = left + ((right -left) >> 1) + 1`
- 左边界更新：`left = mid`
- 右边界更新： `right = mid - 1`
- 返回值： `nums[right] == target ? right : -1`

🚨 这里大部分和寻找左边界是对称着来写的，唯独有一点需要尤其注意 —— <u>中间位置的计算变了，我们在末尾多加了 1。这样，**无论对于奇数还是偶数，这个中间的位置都是偏右的。**</u>

对于这个操作的理解，从对称的角度看，寻找左边界的时候，中间位置是偏左的，那寻找右边界的时候，中间位置就应该偏右，但是这显然不是根本原因。

根本原因是，在最后`left`和`right`相邻时，如果`mid`偏左，则`left`, `mid`指向同一个位置，`right`指向它们的下一个位置，在`nums[left]`已经等于目标值的情况下，这三个位置的值都不会更新，从而进入了死循环。所以我们应该让`mid`偏右，这样`left`就能向右移动。这也就是为什么我们之前一直强调查找条件，判断条件和左右边界的更新方式三者之间需要配合使用。

右边界的查找一般来说不会单独使用，如有需要，一般是需要同时查找左右边界。

#### 📜 对应的 LeetCode

|                            🎯 题解                            | 🎲 难度 |
| :----------------------------------------------------------: | :----: |
| [1337 - 方阵中战斗力最弱的 K 行](计算机基础/算法/LeetCode/二分查找/1337-方阵中战斗力最弱的K行.md) |   😎    |

### ④ 二分查找左右边界

#### 📜 对应的 LeetCode

|                            🎯 题解                            | 🎲 难度 |
| :----------------------------------------------------------: | :----: |
| [34 - 在排序数组中查找元素的第一个和最后一个位置](计算机基础/算法/LeetCode/二分查找/34-在排序数组中查找元素的第一个和最后一个位置.md) |   👻    |

#### 模板详解

前面我们介绍了左边界和右边界的查找，那么查找左右边界就容易很多了——只要分别查找左边界和右边界就行了。

```java
// 二分查找某个数的左右边界
public int[] searchRange(int[] nums, int target) {

    int[] res = new int[]{-1, -1}; // 存储左右边界

    if(nums == null || nums.length == 0) 
        return res;

    // 寻找左边界
    int left = 0;
    int right = nums.length - 1;
    while (left < right) {
        int mid = left + ((right - left) >> 1);
        if (nums[mid] < target) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    res[0] = nums[left] == target ? left : -1;

    // 寻找右边界
    if (res[0] != -1) {
        if (left == nums.length - 1 || nums[left + 1] != target) {
            res[1] = left;
        } 
        else {
            right = nums.length - 1;
            while (left < right) {
                int mid = left + ((right - left) >> 1) + 1;
                if (nums[mid] > target) {
                    right = mid - 1;
                } else {
                    left = mid;
                }
            }
            res[1] = nums[right] == target ? right : -1;
        }
    }

    return res;
}
```

### ⑤ 二分查找极值点

#### 📜 对应的 LeetCode

|                            🎯 题解                            | 🎲 难度 |
| :----------------------------------------------------------: | :----: |
| [852 - 山脉数组的峰顶索引](计算机基础/算法/LeetCode/二分查找/852-山脉数组的峰顶索引.md) |   😎    |

#### 模板详解

二分查找还有一种有趣的变体是二分查找极值点，之前我们使用`nums[mid]`去比较的时候，常常是和给定的目标值`target`比，或者和左右边界比较，在二分查找极值点的应用中，我们是和相邻元素去比，以完成某种单调性的检测。大家直接看 [852 - 山脉数组的峰顶索引](计算机基础/算法/LeetCode/二分查找/852-山脉数组的峰顶索引.md) 这个例子即可明白~

```java
public int binarySearch(int[] arr){
    int left = 0;
    int right = nums.length - 1;

    while(left <= right){
        int mid = left + (right - left) / 2;
        if(arr[mid] > arr[mid+1] && arr[mid] > arr[mid-1])
            return mid;
        else if(arr[mid] > arr[mid+1]){ // 说明峰顶在 mid 左边
            right = mid - 1;
        }
        else{
            left = mid + 1;
        }
    } // end while

    return -1;
}
```

## ✍ LeetCode 汇总 — 二分查找

**【标准的二分查找】**：

|                            🎯 题解                            | 🎲 难度 |
| :----------------------------------------------------------: | :----: |
| [349 - 两个数组的交集](计算机基础/算法/LeetCode/二分查找/349-两个数组的交集.md) |   😎    |
| [1237 - 找出给定方程的正整数解](计算机基础/算法/LeetCode/二分查找/1237-找出给定方程的正整数解.md) |   😎    |
| [374 - 猜数字大小](计算机基础/算法/LeetCode/二分查找/374-猜数字大小.md) |   😎    |
| [69 - x 的平方根](计算机基础/算法/LeetCode/二分查找/69-x的平方根.md) |   😎    |

**【二分查找左边界】**：

|                            🎯 题解                            | 🎲 难度 |
| :----------------------------------------------------------: | :----: |
| [1351 - 统计有序矩阵中的负数](计算机基础/算法/LeetCode/二分查找/1351-统计有序矩阵中的负数.md) |   😎    |
| [278 - 第一个错误的版本](计算机基础/算法/LeetCode/二分查找/278-第一个错误的版本.md) |   😎    |
| [153 - 寻找旋转排序数组中的最小值](计算机基础/算法/LeetCode/二分查找/153-寻找旋转排序数组中的最小值.md) |   👻    |
| [154 - 寻找旋转排序数组中的最小值 II](计算机基础/算法/LeetCode/二分查找/154-寻找旋转排序数组中的最小值II.md) |   👽    |

**【二分查找右边界】**：

|                            🎯 题解                            | 🎲 难度 |
| :----------------------------------------------------------: | :----: |
| [1337 - 方阵中战斗力最弱的 K 行](计算机基础/算法/LeetCode/二分查找/1337-方阵中战斗力最弱的K行.md) |   😎    |

**【二分查找左右边界】**：

|                            🎯 题解                            | 🎲 难度 |
| :----------------------------------------------------------: | :----: |
| [34 - 在排序数组中查找元素的第一个和最后一个位置](计算机基础/算法/LeetCode/二分查找/34-在排序数组中查找元素的第一个和最后一个位置.md) |   👻    |

**【二分查找极值点】**：

|                            🎯 题解                            | 🎲 难度 |
| :----------------------------------------------------------: | :----: |
| [852 - 山脉数组的峰顶索引](计算机基础/算法/LeetCode/二分查找/852-山脉数组的峰顶索引.md) |   😎    |

## 📚 References

- 《算法导论 — 第 3 版 机械工业出版社》
- [LeetCode](https://leetcode-cn.com/problemset/algorithms/)
- [二分查找、二分边界查找算法的模板代码总结](https://segmentfault.com/a/1190000016825704)
- [labuladong 的算法小抄](https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/er-fen-cha-zhao-xiang-jie#si-luo-ji-tong-yi)