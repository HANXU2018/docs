# 338. 比特位计数

---

👉 [338. 比特位计数 — Medium](https://leetcode-cn.com/problems/counting-bits/)

## 📜 题目描述

给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。

示例 1:

```
输入: 2
输出: [0,1,1]
```


示例 2:

```
输入: 5
输出: [0,1,1,2,1,2]
```

## 💡 解题思路 

**【动态规划】**

- 辅助数组的定义：`dp[n]` 表示数字 n 的二进制数中 1 的数目

- 状态转移方程：`dp[n] = dp[n/2] + (n % 2)`

  观察 n 和 n' = n / 2 的关系：

  $n = (1001011101)_2 = (605)_{10}$

  $n' = (100101110)_2 = (302)_{10}$

  可以发现 n/2 与 n 只有一位不同，这是因为 **n/2 可以看做 n 移除最低有效位的结果**。

- base case：`dp[0] = 0`，即数字 0 的二进制数中 1 的数目为 0


## ✅  具体代码


```java
class Solution {
    public int[] countBits(int num) {
        int[] dp = new int[num + 1];
        for(int i = 0; i <= num; i ++)
            dp[i] = dp[i/2] + i % 2;

        return dp;
    }
}
```

