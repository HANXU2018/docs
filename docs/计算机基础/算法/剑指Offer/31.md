# 🚥 31 - 整数中1出现的次数（从1到n整数中1出现的次数）

---

### 题目描述

求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。



### 解题思路

#### 思路1：暴力解法

最简单直接的方法就是我们循环所有的1~n中的每个number，计算每个number出现的次数

该解法见具体代码 Java

#### 思路2：分治递归

该解法见具体代码 C++

① `递归出口：`

- 对于任意一个个位数 n，即从 1 到 n 的整数中 1 出现的次数都是 1 次

- 对于 n<1，即n=0时，从 1 到 n 的整数中 1 出现的次数都是 0 次

② `递归体：`我们考虑用分治的思想将任意一个n位数不断缩小规模分解成许多个个位数，这样求解就很方便。每次去掉最高位然后进行递归，**任意一个n位数中"1"的个位可以分解为两个n-1位数中"1"的个数的和，最后再加上一个与最高位数相关的常数C**

- 对于n = 12，从 1 到 12 的整数中 1 出现的次数. 1、10、11、12 一共 5 次

  可以拆分为即 `f(12) = f(10 - 1) + f(12 - 10) + 3`, 即从 1 到 12 的整数中 1 出现的次数 = 从 1 到 9 的整数中 1 出现的次数（个位上为1的次数：1） + 从 1 到 2 的整数中 1 出现的次数（十位上为 1 的次数 ：1） + 最高位为1的数字个数（此处最高位是十位，最高位为1的数字为 10、11、12  即 3 个）
  
- 对于n = 132，从 1 到 132 的整数中 1 出现的次数.

  可以拆分为即 `f(132) = f(100 - 1) + f(132 - 100) + 33 `, 即从 1 到 132 的整数中 1 出现的次数 = 从 1 到 99 的整数中 1 出现的次数（个位上为1的次数 ） + 从 1 到 32 的整数中 1 出现的次数（十位上为1的次数 ） + 最高位为1的数字个数（此处最高位是百位，最高位为1的数字为 100、101、102 ... 131、132 共 33 个）

- 对于n = 232，从 1 到 232 的整数中 1 出现的次数.

  可以拆分为 `f(232) = 2*f(100 - 1) + f(32) + 100`，此处最高位是百位，最高位为1的次数为 100、101...198、199，所以它包括了所有最高位为1的数字即100~199，共100个。

<br>

​	综上，我们分析得出，**最后加的常数C只跟最高位 n1 是否为1有关**

- <u>当最高位为1时，常数C为原数字N去掉最高位后剩下的数字 +1</u>，如 N=12 时，C = 2 + 1 = 3​，N=132 时，​C = 32 + 1 = 33​

- <u>当最高位大于1时，常数C为 10 ^ (bit - 1)</u>，其中bit为N的位数，如 N=232 时，bit = 3，C = 10^(bit-1) = 10^2 = 100​。 

  于是，我们可以列出递归方程如下：

  ```cpp
  if(n1 == 1)
      f(n) = f(10^bit - 1) + f(n - 10^bit) + n - 10^(bit-1)+ 1;
  else
      f(n) = n1*f(10^(bit-1) - 1) + f(n – n1*10^bit) + 10^(bit-1);
  ```

### 具体代码

- C++

```cpp
class Solution {
public:
    int NumberOf1Between1AndN_Solution(int n){
        return CountOne(n);
    }
    int CountOne(int n){
        if(n == 0)
            return 0;
        else if(n > 1 && n < 10)
            return 1;
        else{
            long highest = n; //最高位的数字
            int bit = 0; // 表示数字的总位数 - 1
            while(highest >= 10){
                highest /= 10;
                bit ++;
            }
            int weight = pow(10,bit); //最高位的1代表的大小
            if(highest == 1) // 如果最高位是1
                return CountOne(weight - 1) + CountOne(n - weight) + (n - weight + 1);
            else //最高位不为1
                return highest*CountOne(weight - 1) + CountOne(n - highest*weight) + weight;
            
        }
    }
};
```

这种思路每次去掉最高位然后进行递归，递归的次数和位数相同。

一个数字n有 O(logN) 位，因此算法的时间复杂度是 O(logN)​



- Java

```java
public class Solution {
    public int NumberOf1Between1AndN_Solution(int n) {
        int count = 0;
        for(int i = 1; i <= n; i++)
            count += CountOne(i);
        return count;
    }
    // 计算数字n中的1的个数
    public int CountOne(int n){
        int numberOfOne = 0;
        while(n != 0){
            if(n % 10 == 1)
                numberOfOne ++;
            n /= 10;
        }
        return numberOfOne;
    }
}
```

时间复杂度为 O(N * lgN)​，N比较大的时候，需要耗费很长的时间。